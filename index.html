<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Isometric Sandbox Game with Trees</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB, #1E90FF);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #inventory {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 10;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            min-width: 220px;
        }

        .inventory-section {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .inventory-section h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #FF9800;
        }

        #materialInventory p, #resourceInventory p[style*="cursor: pointer"] {
            cursor: pointer;
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            transition: all 0.2s;
        }

        #materialInventory p:hover, #resourceInventory p[style*="cursor: pointer"]:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        #materialInventory p.selected, #resourceInventory p.selected {
            background-color: rgba(76, 175, 80, 0.3);
            border: 1px solid #4CAF50;
        }
        
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 10px;
            font-size: 11px;
            z-index: 10;
            width: auto;
            max-width: 400px;
            box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 8px;
        }
        
        .control-item {
            background: rgba(50, 50, 50, 0.5);
            padding: 6px;
            border-radius: 5px;
            text-align: center;
        }
        
        .key {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
            margin: 0 2px;
            font-family: monospace;
            font-size: 10px;
        }
        
        #notification {
    position: absolute;
    top: 20px; /* Changed from 50% */
    left: 50%;
    transform: translateX(-50%); /* Only horizontal centering */
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 15px 30px;
    border-radius: 10px;
    z-index: 20;
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none;
    font-size: 18px;
    text-align: center;
    border: 2px solid #4CAF50;
}
        
        .action-button {
            background: linear-gradient(to bottom, #4CAF50, #2E7D32);
            border: none;
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 10px;
            transition: all 0.2s;
        }
        
        .action-button:hover {
            background: linear-gradient(to bottom, #66BB6A, #388E3C);
            transform: translateY(-2px);
        }
        
        .action-button:active {
            transform: translateY(1px);
        }
        
        #statsBar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 250px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .stat-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .stat-label {
            color: white;
            font-size: 14px;
            font-weight: bold;
            min-width: 60px;
        }
        
        .stat-bar-bg {
            flex: 1;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .stat-bar-fill {
            height: 100%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        
        #healthBar {
            background: linear-gradient(to right, #e74c3c, #c0392b);
        }
        
        #hungerBar {
            background: linear-gradient(to right, #f39c12, #d68910);
        }
        
        #damageOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        #sleepButton {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(to bottom, #9b59b6, #8e44ad);
            border: 2px solid #fff;
            color: white;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            transition: all 0.2s;
            z-index: 15;
            display: none;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { box-shadow: 0 4px 10px rgba(155, 89, 182, 0.5); }
            50% { box-shadow: 0 4px 20px rgba(155, 89, 182, 1); }
        }
        
        #sleepButton:hover {
            background: linear-gradient(to bottom, #a569bd, #9b59b6);
            transform: translateX(-50%) translateY(-2px);
        }
        
        #sleepButton:active {
            transform: translateX(-50%) translateY(1px);
        }
        
        #gameOver {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: #ff0000;
            padding: 40px 60px;
            border-radius: 20px;
            z-index: 200;
            display: none;
            text-align: center;
            border: 4px solid #ff0000;
            box-shadow: 0 0 40px rgba(255, 0, 0, 0.8);
        }
        
        #gameOver h1 {
            font-size: 72px;
            margin: 0 0 20px 0;
            text-shadow: 0 0 20px #ff0000;
            animation: gameOverPulse 1s infinite;
        }
        
        #gameOver p {
            font-size: 24px;
            color: #fff;
            margin: 10px 0;
        }
        
        @keyframes gameOverPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        #gameOver button {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 18px;
            background: #ff0000;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
        }
        
        #gameOver button:hover {
            background: #cc0000;
        }

        .side-menu {
            position: absolute;
            top: 0;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            z-index: 10;
            transition: transform 0.3s ease-in-out;
            max-height: 100vh;
            overflow-y: auto;
            width: 250px;
        }

        #leftMenu {
            left: 0;
            transform: translateX(-250px);
        }
        #leftMenu.open {
            transform: translateX(0);
        }

        #rightMenu {
            right: 0;
            transform: translateX(250px);
        }
        #rightMenu.open {
            transform: translateX(0);
        }

        .menu-toggle {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            background: #ff9800;
            border: none;
            color: white;
            cursor: pointer;
            padding: 10px 5px;
            z-index: 11;
        }
        
        #leftMenuToggle {
            left: 0;
            border-radius: 0 5px 5px 0;
        }
        #rightMenuToggle {
            right: 0;
            border-radius: 5px 0 0 5px;
        }
    </style>
</head>
<body>
    <button id="leftMenuToggle" class="menu-toggle">&gt;</button>
    <div id="leftMenu" class="side-menu">
        <div id="skillsContainer">
            <h3>Skills</h3>
            <div id="skillsList"></div>
        </div>
        <div id="controls">
            <div>Game Controls</div>
            <div class="controls-grid">
                <div class="control-item">
                    Movement: <span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span>
                </div>
                <div class="control-item">
                    Destroy Block: <span class="key">SPACE</span>
                </div>
                <div class="control-item">
                    Place Block: <span class="key">ALT</span>
                </div>
                <div class="control-item">
                    Use Tool/Harvest: <span class="key">SHIFT</span>
                </div>
                <div class="control-item">
                    Zoom: <span class="key">MOUSE WHEEL</span>
                </div>
                <div class="control-item">
                    Select Item: <span class="key">CLICK</span>
                </div>
                <div class="control-item">
                    Eat Fruit: <span class="key">F</span>
                </div>
                <div class="control-item">
                    Use Herb: <span class="key">H</span>
                </div>
                <div class="control-item">
                    Jump: <span class="key">Z</span>
                </div>
                <div class="control-item">
                    Sleep (Night): <span class="key">N</span>
                </div>
            </div>
        </div>
    </div>

    <button id="rightMenuToggle" class="menu-toggle">&lt;</button>
    <div id="rightMenu" class="side-menu">
        <div id="inventory">
            <h3>Inventory</h3>
            <div class="inventory-section">
                <h4>Game State</h4>
                <button id="saveButton" class="action-button">Save Game</button>
                <input type="file" id="loadInput" style="display: none;">
                <button id="loadButton" class="action-button">Load Game</button>
            </div>
            <div class="inventory-section">
                <h4>Materials</h4>
                <div id="materialInventory"></div>
            </div>
            <div class="inventory-section">
                <h4>Resources</h4>
                <div id="resourceInventory"></div>
            </div>
            <div class="inventory-section">
                <h4>Tools</h4>
                <div id="toolInventory"></div>
            </div>
            <button id="plantButton" class="action-button">Plant Tree (Seeds)</button>
        </div>
    </div>

    <div id="gameContainer"></div>
    <div id="statsBar">
        <div class="stat-container">
            <span class="stat-label">Health:</span>
            <div class="stat-bar-bg">
                <div id="healthBar" class="stat-bar-fill" style="width: 100%;">100%</div>
            </div>
        </div>
        <div class="stat-container">
            <span class="stat-label">Hunger:</span>
            <div class="stat-bar-bg">
                <div id="hungerBar" class="stat-bar-fill" style="width: 100%;">100%</div>
            </div>
        </div>
    </div>
    
    <div id="notification"></div>
    <button id="sleepButton">Sleep (Skip 10 min)</button>
    <div id="damageOverlay"></div>
    <div id="gameOver">
        <h1>GAME OVER</h1>
        <p id="deathReason">You died!</p>
        <button onclick="location.reload()">Restart</button>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game variables
        let scene, camera, renderer;
        let player, terrain = [], blockMeshes = [], trees = [];
        let worldSize = 60;
        let blockSize = 1;
        
        // Material caching for better performance
        let cachedSoilMaterials = null;
        let cachedRockMaterial = null;
        let cachedMetalMaterial = null;
        let cachedWoodMaterial = null;
        let cachedWaterMaterial = null;
        let noiseScale = 0.05;
        let playerPos = new THREE.Vector3(30, 0, 30); // Center of 60x60 world
        let keys = {};
        let cameraAngle = 0;        // radians around the player
        const rotationSpeed = 0.03; // radians per key-press
        let playerLastMoveDirection = new THREE.Vector3(0, 0, 0);
        let inventory = {};
        let selectedMaterials = new Set(); // Changed from single selectedMaterial to Set
        const TOOLS = {
            PICKAXE: { id: 0, name: 'Pickaxe' },
            AXE: { id: 1, name: 'Axe' },
            FISHING_ROD: { id: 2, name: 'Fishing Rod' },
            SWORD: { id: 3, name: 'Sword' }
        };
        let equippedTool = null;
        let playerAnimationsWithPickaxe = {
            idleFront: null,
            idleBack: null,
            runFront: null,
            runBack: null,
            miningFront: null,
            miningBack: null
        };
        //updateCamera
        let playerAnimationsWithAxe = {
            idleFront: null,
            idleBack: null,
            runFront: null,
            runBack: null,
            cuttingFront: null,
            cuttingBack: null
        };
        let playerAnimationsWithSword = {
            idleFront: null,
            idleBack: null,
            runFront: null,
            runBack: null,
            attackFront: null,
            attackBack: null
        };
        let playerAnimationsWithFishingRod = {
            idleFront: null,
            idleBack: null,
            runFront: null,
            runBack: null,
            castingFront: null,
            waitingFront: null,
            fishBiteFront: null,
            catchingFront: null
        };
        let isUsingTool = false;
        let toolAnimationComplete = true;
        let plantingSeeds = false;
        let plantingBushSeeds = false;
        let isFishing = false;
        let fishingStartTime = 0;
        let fishingWaitTime = 0;
        let fishingState = 'idle'; // 'idle', 'casting', 'waiting', 'bite', 'catching'

        // Campfires
        let campfires = [];
        let campfireTexture;
        let campfireAnimation = null;

        // Player Skills
        let skills = {
            mining: 0,
            fishing: 0,
            lumberjacking: 0,
            fighting: 0,
            manufacturing: 0,
            construction: 0
        };
        const MAX_SKILL_LEVEL = 30;

        // Long Action variables
        let isPerformingLongAction = false;
        let longActionType = null;
        let longActionStartTime = 0;
        let longActionDuration = 0;
        let longActionOnComplete = null;
        let miningProgressIndicator;


        let globalTreeTexture; // Store tree texture globally
        let globalTreeWithFruitTexture; // Store tree with fruit texture globally
        let lastGrowthUpdate = 0; // For tree growth timing
        
        // Player stats
        let hunger = 100; // 0-100%
        let health = 100; // 0-100%
        let lastHungerUpdate = 0;
        
        // Rain system
        let isRaining = false;
        let rainStartTime = 0;
        let lastRainCycle = 0;
        let rainParticles = null;
        const RAIN_CYCLE_DURATION = 600000; // 10 minutes
        const RAIN_DURATION = 60000; // 1 minute
        const RAIN_DAMAGE_PER_SECOND = 0.5;
        
        // Day/Night cycle
        let gameStartTime = 0;
        let isNightTime = false;
        let directionalLight;
        const DAY_NIGHT_CYCLE = 900000; // 15 minutes
        let lastNightDamageTime = 0;
        
        // Material textures
        let grassTexture, soilTexture, rockTexture, metalTexture, woodTexture, waterTexture;
        
        // Bushes
        let bushes = [];
        let bushTexture;
        const MEDICINAL_HERB_BUSH_INDEX = 4; // Fifth bush (index 4) is medicinal
        const FLAX_BUSH_INDEX = 3; // Fourth bush (index 3) is Flax
        const HERB_REGROW_TIME = 300000; // 5 minutes in milliseconds
        
        // Bears
        let bears = [];
        let bearTexture;
        const BEAR_SPEED = 0.05; // Slowed down from 0.08
        const BEAR_CHASE_DISTANCE = 5; // Distance at which bear starts chasing
        const BEAR_ATTACK_DISTANCE = 1.5; // Distance at which bear attacks
        const BEAR_ATTACK_DAMAGE = 5; // Damage per attack
        const BEAR_ATTACK_COOLDOWN = 2000; // 2 seconds between attacks
        const BEAR_MAX_HEALTH = 2000;
        const PLAYER_ATTACK_DAMAGE = 25;
        
        // Helper function to calculate wrapped distance
        function getWrappedDistance(x1, z1, x2, z2) {
            const dx = Math.abs(x1 - x2);
            const dz = Math.abs(z1 - z2);
            const wrappedDx = Math.min(dx, worldSize - dx);
            const wrappedDz = Math.min(dz, worldSize - dz);
            return Math.sqrt(wrappedDx * wrappedDx + wrappedDz * wrappedDz);
        }
        
        function getWrappedDirection(fromX, fromZ, toX, toZ) {
            let dx = toX - fromX;
            let dz = toZ - fromZ;
            
            // Wrap around if shorter path exists
            if (dx > worldSize / 2) dx -= worldSize;
            if (dx < -worldSize / 2) dx += worldSize;
            if (dz > worldSize / 2) dz -= worldSize;
            if (dz < -worldSize / 2) dz += worldSize;
            
            return new THREE.Vector3(dx, 0, dz).normalize();
        }
        
        // Wolves
        let wolves = [];
        let wolfTexture;
        const WOLF_SPEED = 0.08; // Slowed down from 0.12
        const WOLF_CHASE_DISTANCE = 6; // Wolves detect from farther away
        const WOLF_ATTACK_DISTANCE = 1.3; // Attack distance
        const WOLF_ATTACK_DAMAGE = 2; // Less damage than bears
        const WOLF_ATTACK_COOLDOWN = 1500; // 1.5 seconds between attacks
        const WOLF_MAX_HEALTH = 1000;
//updateFal
        // Camera offset from player - zoomed in 33% closer
        const cameraOffset = new THREE.Vector3(-1.875, 2.505, -1.875);

        // Block materials with frequency property
        const MATERIALS = {
            SOIL: { id: 0, name: 'Soil', color: 0x8B4513, topColor: 0x228B22, frequency: 4 },
            ROCK: { id: 1, name: 'Rock', color: 0x696969, frequency: 3 },
            METAL: { id: 3, name: 'Metal', color: 0xB0C4DE, frequency: 1 },
            WOOD: { id: 2, name: 'Wood', color: 0x8B4513, frequency: 0 }, // Wood material added
            WATER: { id: 4, name: 'Water', color: 0x006994, frequency: 0 } // Water material added
        };

        // Animation variables
        let playerAnimations = {
            idleFront: null,
            idleBack: null,
            runFront: null,
            runBack: null
        };
        let currentAnimation = null;
        let playerSprite = null;
        let lastAnimationTime = 0;
        let playerFacing = 'front';
        let playerFlipX = false;

        // Tree sprite visual offsets
        let treeSpriteOffsets = [];

        // Tree properties
        const TREE_TYPES = [
            { id: 0, name: "Oak", minWood: 3, maxWood: 5, minSeeds: 1, maxSeeds: 3 },
            { id: 1, name: "Pine", minWood: 4, maxWood: 6, minSeeds: 1, maxSeeds: 2 },
            { id: 2, name: "Birch", minWood: 2, maxWood: 4, minSeeds: 2, maxSeeds: 4 },
            { id: 3, name: "Maple", minWood: 3, maxWood: 5, minSeeds: 1, maxSeeds: 3 },
            { id: 4, name: "Palm", minWood: 2, maxWood: 3, minSeeds: 1, maxSeeds: 2 },
            { id: 5, name: "Redwood", minWood: 5, maxWood: 8, minSeeds: 1, maxSeeds: 1 },
            { id: 6, name: "Willow", minWood: 3, maxWood: 4, minSeeds: 2, maxSeeds: 4 },
            { id: 7, name: "Cherry", minWood: 3, maxWood: 5, minSeeds: 1, maxSeeds: 3 }
        ];

        // Sprite Animator Class create generateTrees
        class SpriteAnimator {
            constructor(texture, horizontalFrames, verticalFrames, frameDuration, loop = true) {
                this.texture = texture;
                this.horizontalFrames = horizontalFrames;
                this.verticalFrames = verticalFrames;
                this.frameDuration = frameDuration;
                this.totalFrames = horizontalFrames * verticalFrames;
                this.loop = loop;
                
                this.frameWidth = 1 / horizontalFrames;
                this.frameHeight = 1 / verticalFrames;
                
                this.currentFrame = 0;
                this.animationTime = 0;
                this.playing = false;
                this.completed = false;
                
                this.texture.wrapS = THREE.RepeatWrapping;
                this.texture.wrapT = THREE.RepeatWrapping;
                this.texture.repeat.set(this.frameWidth, this.frameHeight);
                
                this.updateFrame(0);
            }
            
            updateFrame(frameIndex) {
                const column = frameIndex % this.horizontalFrames;
                const row = Math.floor(frameIndex / this.horizontalFrames);
                
                this.texture.offset.x = column * this.frameWidth;
                this.texture.offset.y = 1 - (row + 1) * this.frameHeight;
            }
            
            play() {
                this.playing = true;
                this.animationTime = 0;
                this.currentFrame = 0;
                this.completed = false;
            }
            
            stop() {
                this.playing = false;
            }
            
            update(deltaTime) {
                if (!this.playing) return;
                
                this.animationTime += deltaTime;
                
                const newFrame = Math.floor(this.animationTime / this.frameDuration);
                
                if (newFrame !== this.currentFrame) {
                    if (newFrame >= this.totalFrames) {
                        if (this.loop) {
                            this.currentFrame = newFrame % this.totalFrames;
                        } else {
                            this.currentFrame = this.totalFrames - 1;
                            this.completed = true;
                            this.stop();
                        }
                    } else {
                        this.currentFrame = newFrame;
                    }
                    this.updateFrame(this.currentFrame);
                }
            }
        }
        
        function calculateTreeSpriteOffsets() {
            const canvas = globalTreeTexture.image;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            if (!ctx) {
                console.error("Could not get 2D context from texture canvas.");
                return;
            }
            const atlasWidth = canvas.width;
            const atlasHeight = canvas.height;

            const cols = 4, rows = 2;
            const subImageWidth = atlasWidth / cols;
            const subImageHeight = atlasHeight / rows;

            for (let i = 0; i < TREE_TYPES.length; i++) {
                const col = i % cols;
                const row = Math.floor(i / rows);

                const startX = col * subImageWidth;
                const startY = row * subImageHeight;

                const imageData = ctx.getImageData(startX, startY, subImageWidth, subImageHeight);
                const data = imageData.data;

                let lowestY = subImageHeight;

                for (let y = subImageHeight - 1; y >= 0; y--) {
                    let rowHasPixel = false;
                    for (let x = 0; x < subImageWidth; x++) {
                        const alpha = data[(y * subImageWidth + x) * 4 + 3];
                        if (alpha > 50) { // Using a threshold to ignore barely visible pixels
                            lowestY = y;
                            rowHasPixel = true;
                            break; 
                        }
                    }
                    if (rowHasPixel) {
                        break;
                    }
                }
                
                // Calculate the offset from the bottom of the sprite box
                const offset = (subImageHeight - 1 - lowestY) / subImageHeight;
                treeSpriteOffsets[i] = offset > 0 ? offset : 0;
            }
        }
        
        // Show notification
        function showNotification(message, duration = 2000) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.opacity = 1;
            
            setTimeout(() => {
                notification.style.opacity = 0;
            }, duration);
        }

        // Initialize the game
        async function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            // Add fog for reduced draw distance - 2x closer
            scene.fog = new THREE.Fog(0x87CEEB, 5, 15); // Start at 5 blocks, complete at 15 blocks

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 25); // Reduced far plane to 25

            renderer = new THREE.WebGLRenderer({ 
                antialias: false,
                powerPreference: "high-performance" // Use high-performance GPU
            });
            // Render at 1/16 resolution (16x more pixelated) for performance
            renderer.setSize(window.innerWidth / 4, window.innerHeight / 4);
            renderer.domElement.style.width = '100vw';
            renderer.domElement.style.height = '100vh';
            renderer.domElement.style.imageRendering = 'pixelated';
            renderer.shadowMap.enabled = false; // Disabled shadows for better performance
            document.getElementById('gameContainer').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x404040, 0.9);
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(50, 50, 25);
            scene.add(directionalLight);

            // Load textures
            const textureLoader = new THREE.TextureLoader();
        
            const loadTexture = (url) => new Promise(resolve => {
                const tex = textureLoader.load(url, resolve);
                tex.minFilter = THREE.NearestFilter;
                tex.magFilter = THREE.NearestFilter;
            });
            
            const loadTextureWithTransparency = (url, fallbackColor = 0xFF00FF) => new Promise(resolve => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    // Create canvas to process image
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    
                    // Get image data and make white pixels transparent
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        
                        // If pixel is white or near-white, make it transparent
                        if (r > 240 && g > 240 && b > 240) {
                            data[i + 3] = 0; // Set alpha to 0
                        }
                    }
                    
                    ctx.putImageData(imageData, 0, 0);
                    
                    // Create texture from canvas
                    const texture = new THREE.CanvasTexture(canvas);
                    texture.minFilter = THREE.NearestFilter;
                    texture.magFilter = THREE.NearestFilter;
                    texture.needsUpdate = true;
                    resolve(texture);
                };
                img.onerror = () => {
                    console.warn(`Failed to load texture: ${url}. Using fallback.`);
                    const canvas = document.createElement('canvas');
                    canvas.width = 32;
                    canvas.height = 32;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#' + fallbackColor.toString(16).padStart(6, '0');
                    ctx.fillRect(0, 0, 32, 32);
                    const texture = new THREE.CanvasTexture(canvas);
                    texture.minFilter = THREE.NearestFilter;
                    texture.magFilter = THREE.NearestFilter;
                    resolve(texture);
                };
                img.src = url;
            });
            
            const loadTextureDownsampled = (url, scale = 4) => new Promise(resolve => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    // Create canvas at reduced resolution
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width / scale;
                    canvas.height = img.height / scale;
                    const ctx = canvas.getContext('2d');
                    
                    // Disable smoothing for pixelated look
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    
                    // Create texture from downsampled canvas
                    const texture = new THREE.CanvasTexture(canvas);
                    texture.minFilter = THREE.NearestFilter;
                    texture.magFilter = THREE.NearestFilter;
                    texture.needsUpdate = true;
                    resolve(texture);
                };
                img.onerror = () => {
                     console.warn(`Failed to load texture: ${url}. Using fallback.`);
                     const canvas = document.createElement('canvas');
                     canvas.width = 32; canvas.height = 32;
                     const ctx = canvas.getContext('2d');
                     ctx.fillStyle = '#00FF00'; // Green fallback
                     ctx.fillRect(0,0,32,32);
                     resolve(new THREE.CanvasTexture(canvas));
                };
                img.src = url;
            });
        
            // Load regular animations
            const idleFrontTexture = await loadTexture('https://res.cloudinary.com/julianbullmagic/image/upload/v1749555268/idle_front_ouczmk.png');
            const idleBackTexture = await loadTexture('https://res.cloudinary.com/julianbullmagic/image/upload/v1749555251/idle_back_ynbp4i.png');
            const runFrontTexture = await loadTexture('https://res.cloudinary.com/julianbullmagic/image/upload/v1749555364/run_front_tshbuo.png');
            const runBackTexture = await loadTexture('https://res.cloudinary.com/julianbullmagic/image/upload/v1749555358/run_back_moavxi.png');
            
            // Load pickaxe animations
            const idlePickaxeFrontTexture = await loadTexture('https://res.cloudinary.com/julianbullmagic/image/upload/v1749555315/idle_whit_pickaxe_front_hyk0td.png');
            const idlePickaxeBackTexture = await loadTexture('https://res.cloudinary.com/julianbullmagic/image/upload/v1749555251/idle_back_ynbp4i.png');
            const runPickaxeFrontTexture = await loadTexture('https://res.cloudinary.com/julianbullmagic/image/upload/v1749616142/run_whit_pickaxe_front_wfogfs.png');
            const runPickaxeBackTexture = await loadTexture('https://res.cloudinary.com/julianbullmagic/image/upload/v1749616139/run_whit_pickaxe_back_jxdwm0.png');
            const miningFrontTexture = await loadTexture('https://res.cloudinary.com/julianbullmagic/image/upload/v1749555351/mining_front_bj6d3k.png');
            const miningBackTexture = await loadTexture('https://res.cloudinary.com/julianbullmagic/image/upload/v1749555344/mining_back_z4tivx.png');
            
            // Load axe animations
            const idleAxeFrontTexture = await loadTexture('https://res.cloudinary.com/julianbullmagic/image/upload/v1749555296/idle_whit_axe_front_ts0p34.png');
            const idleAxeBackTexture = await loadTexture('https://res.cloudinary.com/julianbullmagic/image/upload/v1749555282/idle_whit_axe_back_pqgkrl.png');
            const runAxeFrontTexture = await loadTexture('https://res.cloudinary.com/julianbullmagic/image/upload/v1749555380/run_whit_axe_front_oedqfi.png');
            const runAxeBackTexture = await loadTexture('https://res.cloudinary.com/julianbullmagic/image/upload/v1749555373/run_whit_axe_back_cdzyqg.png');
            const cuttingFrontTexture = await loadTexture('https://res.cloudinary.com/julianbullmagic/image/upload/v1749555186/cutting_tree_front_enon7m.png');
            const cuttingBackTexture = await loadTexture('https://res.cloudinary.com/julianbullmagic/image/upload/v1749555180/cutting_tree_back_huunqw.png');

            // Load sword animations
            const idleSwordFrontTexture = await loadTexture('https://res.cloudinary.com/dfksh5mnb/image/upload/v1703651865/idle_whit_sword_front_jo36oj.png');
            const idleSwordBackTexture = await loadTexture('https://res.cloudinary.com/dfksh5mnb/image/upload/v1703651860/idle_whit_sword_back_btnp8f.png');
            const runSwordFrontTexture = await loadTexture('https://res.cloudinary.com/dfksh5mnb/image/upload/v1703651907/run_whit_sword_front_xq86b4.png');
            const runSwordBackTexture = await loadTexture('https://res.cloudinary.com/dfksh5mnb/image/upload/v1703651904/run_whit_sword_back_rhfdwu.png');
            const attackSwordFrontTexture = await loadTexture('https://res.cloudinary.com/dfksh5mnb/image/upload/v1703651651/attack_01_front_ybvmrv.png');
            const attackSwordBackTexture = await loadTexture('https://res.cloudinary.com/dfksh5mnb/image/upload/v1703651707/attack_01_back_yetngq.png');
            
            // Load campfire texture
            campfireTexture = await loadTextureWithTransparency('https://res.cloudinary.com/dfksh5mnb/image/upload/v1705104302/CampFireFinished_xozgsa.png');

            // Load animal textures
            catTexture = await loadTextureWithTransparency('https://res.cloudinary.com/dfksh5mnb/image/upload/v1765429473/cat_uq5dty.jpg', 0xFFA500);
            chickenTexture = await loadTextureWithTransparency('https://res.cloudinary.com/dfksh5mnb/image/upload/v1765284202/chicken_ykypbk.jpg', 0xFFFFFF);
            // Assuming these are the generated images for Cow and Dragon based on previous context
            cowTexture = await loadTextureWithTransparency('https://res.cloudinary.com/dfksh5mnb/image/upload/v1765285447/Gemini_Generated_Image_53p13f53p13f53p1_qxrpg9.png', 0x8B4513); 
            dragonTexture = await loadTextureWithTransparency('https://res.cloudinary.com/dfksh5mnb/image/upload/v1765284531/Gemini_Generated_Image_a5drtha5drtha5dr_dqoc2p.png', 0xFF0000);

            // Load fishing animations
            const idleFishingFrontTexture = await loadTexture('https://res.cloudinary.com/dfksh5mnb/image/upload/v1703651832/idle_fishing_front_aupnm2.png');
            const idleWithFishingRodFrontTexture = await loadTexture('https://res.cloudinary.com/dfksh5mnb/image/upload/v1703651848/idle_whit_fishing_rod_front_yamiem.png');
            const runWithFishingRodFrontTexture = await loadTexture('https://res.cloudinary.com/dfksh5mnb/image/upload/v1703651894/run_whit_fishing_rod_front_cgzcfn.png');
            const throwingFishingRodFrontTexture = await loadTexture('https://res.cloudinary.com/dfksh5mnb/image/upload/v1703651912/throwing_fishing_rod_front_ritizd.png');
            const fishBitTheLineFrontTexture = await loadTexture('https://res.cloudinary.com/dfksh5mnb/image/upload/v1703651826/fish_bit_the_line_front_ivoqvr.png');
            const strugglingWithFishFrontTexture = await loadTexture('https://res.cloudinary.com/dfksh5mnb/image/upload/v1703651910/struggling_whit_the_fish_front_uhh8oa.png');
            const catchingTheFishFrontTexture = await loadTexture('https://res.cloudinary.com/dfksh5mnb/image/upload/v1703651775/catching_the_fish_front_zqraqm.png');

            // Create regular animations
            playerAnimations.idleFront = new SpriteAnimator(idleFrontTexture, 8, 1, 0.1);
            playerAnimations.idleBack = new SpriteAnimator(idleBackTexture, 8, 1, 0.1);
            playerAnimations.runFront = new SpriteAnimator(runFrontTexture, 8, 1, 0.1);
            playerAnimations.runBack = new SpriteAnimator(runBackTexture, 8, 1, 0.1);
            
            // Create pickaxe animations
            playerAnimationsWithPickaxe.idleFront = new SpriteAnimator(idlePickaxeFrontTexture, 8, 1, 0.1);
            playerAnimationsWithPickaxe.idleBack = new SpriteAnimator(idlePickaxeBackTexture, 8, 1, 0.1);
            playerAnimationsWithPickaxe.runFront = new SpriteAnimator(runPickaxeFrontTexture, 8, 1, 0.1);
            playerAnimationsWithPickaxe.runBack = new SpriteAnimator(runPickaxeBackTexture, 8, 1, 0.1);
            playerAnimationsWithPickaxe.miningFront = new SpriteAnimator(miningFrontTexture, 8, 1, 0.05, false);
            playerAnimationsWithPickaxe.miningBack = new SpriteAnimator(miningBackTexture, 8, 1, 0.05, false);
            
            // Create axe animations
            playerAnimationsWithAxe.idleFront = new SpriteAnimator(idleAxeFrontTexture, 8, 1, 0.1);
            playerAnimationsWithAxe.idleBack = new SpriteAnimator(idleAxeBackTexture, 8, 1, 0.1);
            playerAnimationsWithAxe.runFront = new SpriteAnimator(runAxeFrontTexture, 8, 1, 0.1);
            playerAnimationsWithAxe.runBack = new SpriteAnimator(runAxeBackTexture, 8, 1, 0.1);
            playerAnimationsWithAxe.cuttingFront = new SpriteAnimator(cuttingFrontTexture, 8, 1, 0.05, false);
            playerAnimationsWithAxe.cuttingBack = new SpriteAnimator(cuttingBackTexture, 8, 1, 0.05, false);
            
            // Create sword animations
            playerAnimationsWithSword.idleFront = new SpriteAnimator(idleSwordFrontTexture, 8, 1, 0.1);
            playerAnimationsWithSword.idleBack = new SpriteAnimator(idleSwordBackTexture, 8, 1, 0.1);
            playerAnimationsWithSword.runFront = new SpriteAnimator(runSwordFrontTexture, 8, 1, 0.1);
            playerAnimationsWithSword.runBack = new SpriteAnimator(runSwordBackTexture, 8, 1, 0.1);
            playerAnimationsWithSword.attackFront = new SpriteAnimator(attackSwordFrontTexture, 6, 1, 0.08, false); // 6 frames? Checking spritesheet size... usually 6-8
            playerAnimationsWithSword.attackBack = new SpriteAnimator(attackSwordBackTexture, 6, 1, 0.08, false);

            // Create campfire animation
            // Campfire spritesheet usually has multiple frames. The provided image looks like a spritesheet.
            // Assuming 1x5 or similar.
            campfireAnimation = new SpriteAnimator(campfireTexture, 5, 1, 0.15); // Adjust frames if needed

            // Create fishing animations
            playerAnimationsWithFishingRod.idleFront = new SpriteAnimator(idleWithFishingRodFrontTexture, 8, 1, 0.1);
            playerAnimationsWithFishingRod.idleBack = new SpriteAnimator(idleWithFishingRodFrontTexture, 8, 1, 0.1); // Use front for back
            playerAnimationsWithFishingRod.runFront = new SpriteAnimator(runWithFishingRodFrontTexture, 8, 1, 0.1);
            playerAnimationsWithFishingRod.runBack = new SpriteAnimator(runWithFishingRodFrontTexture, 8, 1, 0.1); // Use front for back
            playerAnimationsWithFishingRod.castingFront = new SpriteAnimator(throwingFishingRodFrontTexture, 8, 1, 0.2, false); // Slower animation so it's more visible
            playerAnimationsWithFishingRod.waitingFront = new SpriteAnimator(idleFishingFrontTexture, 8, 1, 0.1);
            playerAnimationsWithFishingRod.fishBiteFront = new SpriteAnimator(fishBitTheLineFrontTexture, 8, 1, 0.2, false); // Slower animation so it's more visible
            playerAnimationsWithFishingRod.catchingFront = new SpriteAnimator(catchingTheFishFrontTexture, 8, 1, 0.2, false); // Slower animation so it's more visible
            
            // Load tree texture - downsampled 4x for performance
            const treeTexture = await loadTextureDownsampled('https://res.cloudinary.com/julianbullmagic/image/upload/v1749694431/set-variety-trees-transparent-background_vr8wak.png', 4);
            globalTreeTexture = treeTexture; // Store globally for tree planting
            
            calculateTreeSpriteOffsets();

            // Load tree with fruit texture - downsampled 4x for performance
            const treeWithFruitTexture = await loadTextureDownsampled('https://res.cloudinary.com/julianbullmagic/image/upload/v1759239290/trees_ism7np.png', 4);
            globalTreeWithFruitTexture = treeWithFruitTexture; // Store globally for tree planting
            
            // Load bear texture
            bearTexture = await loadTexture('https://res.cloudinary.com/julianbullmagic/image/upload/v1759330743/7260-0aefaae1cbadbc607804183722475623_ebo4vd.png');
            
            // Load wolf texture
            wolfTexture = await loadTexture('https://res.cloudinary.com/julianbullmagic/image/upload/v1759331784/R_iftjng.png');
            
            // Load bush texture with white-to-transparent conversion
            bushTexture = await loadTextureWithTransparency('https://res.cloudinary.com/julianbullmagic/image/upload/v1759404830/Free-Bush-Assets-Pixel-Art-Pack3-1536x1024_ijjhmx.jpg');
            
            // Load terrain textures - use linear filtering for grass and soil to look better
            grassTexture = textureLoader.load('https://res.cloudinary.com/julianbullmagic/image/upload/v1758544939/istockphoto-1159879162-170667a_dyidfd.jpg');
            grassTexture.wrapS = THREE.RepeatWrapping;
            grassTexture.wrapT = THREE.RepeatWrapping;
            grassTexture.repeat.set(1, 1);
            
            soilTexture = textureLoader.load('https://res.cloudinary.com/julianbullmagic/image/upload/v1759284152/OIP_1_elwheb.webp');
            soilTexture.wrapS = THREE.RepeatWrapping;
            soilTexture.wrapT = THREE.RepeatWrapping;
            soilTexture.repeat.set(1, 1);
            
            rockTexture = textureLoader.load('https://res.cloudinary.com/julianbullmagic/image/upload/v1759284300/rock_egnkjt.webp');
            rockTexture.wrapS = THREE.RepeatWrapping;
            rockTexture.wrapT = THREE.RepeatWrapping;
            rockTexture.repeat.set(1, 1);
            rockTexture.minFilter = THREE.NearestFilter;
            rockTexture.magFilter = THREE.NearestFilter;
            
            metalTexture = textureLoader.load('https://res.cloudinary.com/julianbullmagic/image/upload/v1759284227/brushedsteel4_czfdim.jpg');
            metalTexture.wrapS = THREE.RepeatWrapping;
            metalTexture.wrapT = THREE.RepeatWrapping;
            metalTexture.repeat.set(1, 1);
            metalTexture.minFilter = THREE.NearestFilter;
            metalTexture.magFilter = THREE.NearestFilter;
            
            woodTexture = textureLoader.load('https://res.cloudinary.com/julianbullmagic/image/upload/v1759335464/360_F_186070679_Ld3HCxdUUp5hh0QrEKT0tKsbAT8JhhUs_ywn0ij.jpg');
            woodTexture.wrapS = THREE.RepeatWrapping;
            woodTexture.wrapT = THREE.RepeatWrapping;
            woodTexture.repeat.set(1, 1);
            woodTexture.minFilter = THREE.NearestFilter;
            woodTexture.magFilter = THREE.NearestFilter;
            
            waterTexture = textureLoader.load('https://res.cloudinary.com/dfksh5mnb/image/upload/v1760436450/R_1_jxujzz.jpg');
            waterTexture.wrapS = THREE.RepeatWrapping;
            waterTexture.wrapT = THREE.RepeatWrapping;
            waterTexture.repeat.set(1, 1);
            waterTexture.minFilter = THREE.NearestFilter;
            waterTexture.magFilter = THREE.NearestFilter;
            
            generateTerrain();
            generateTrees(treeTexture);
            validateTrees(); // Remove any floating trees
            generateBushes(); // Spawn bushes
            generateBears(); // Spawn bears
            generateWolves(); // Spawn wolves
            createPlayer();

            // Mining progress indicator
            const indicatorGeometry = new THREE.BoxGeometry(blockSize * 1.05, blockSize * 1.05, blockSize * 1.05);
            const indicatorMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.5 });
            miningProgressIndicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
            miningProgressIndicator.visible = false;
            scene.add(miningProgressIndicator);

            updateCameraPosition();
            setupControls();
            updateInventoryUI();
            updateSkillsUI();

            // Initialize last growth update time
            lastGrowthUpdate = Date.now();
            lastHungerUpdate = Date.now();
            lastRainCycle = Date.now();
            gameStartTime = Date.now();
            lastNightDamageTime = Date.now();
            
            // Create rain particle system
            createRainSystem();
            
            animate();
        }
        
        function updateDayNightCycle() {
            const now = Date.now();
            const timeSinceStart = now - gameStartTime;
            const cycleProgress = (timeSinceStart % DAY_NIGHT_CYCLE) / DAY_NIGHT_CYCLE;
            
            // First half is day, second half is night
            const wasNight = isNightTime;
            isNightTime = cycleProgress >= 0.5;
            
            // Notify when transitioning
            if (isNightTime && !wasNight) {
                showNotification("Night has fallen! Sleep or risk losing health!", 3000);
            } else if (!isNightTime && wasNight) {
                showNotification("Day has arrived!", 2000);
            }
            
            // Adjust lighting and sky color based on time of day
            if (isNightTime) {
                // Night time - dark
                directionalLight.intensity = 0.2;
                scene.background.setHex(0x1a1a2e);
                scene.fog.color.setHex(0x1a1a2e);
            } else {
                // Day time - bright
                directionalLight.intensity = 0.5;
                scene.background.setHex(0x87CEEB);
                scene.fog.color.setHex(0x87CEEB);
            }
            
            // Apply night damage
            if (isNightTime) {
                const timeSinceLastDamage = (now - lastNightDamageTime) / 1000;
                if (timeSinceLastDamage >= 1) {
                    health = Math.max(0, health - RAIN_DAMAGE_PER_SECOND);
                    updateStatsUI();
                    showDamageEffect('night');
                    lastNightDamageTime = now;
                    
                    if (health === 0) {
                        showGameOver("You died from exhaustion at night!");
                    }
                }
            } else {
                // Clear night damage effect during day
                if (!isRaining || checkPlayerShelter()) {
                    clearDamageEffect();
                }
            }
            
            // Show/hide sleep button based on night time
            const sleepButton = document.getElementById('sleepButton');
            if (sleepButton) {
                sleepButton.style.display = isNightTime ? 'block' : 'none';
            }
        }
        
        function sleepPlayer() {
            // Skip 10 minutes forward
            gameStartTime -= 600000; // Subtract 10 minutes
            lastRainCycle -= 600000; // Also adjust rain cycle
            showNotification("You slept for 10 minutes...", 2000);
            saveGameState();
        }
        
        function showGameOver(reason) {
            const gameOverDiv = document.getElementById('gameOver');
            const deathReasonP = document.getElementById('deathReason');
            deathReasonP.textContent = reason;
            gameOverDiv.style.display = 'block';
            saveGameState(); // Save final state
        }
        
        function createRainSystem() {
            const particleCount = 2000; // More particles for larger world
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            
            // Initialize rain particles above player area - adjusted for larger world
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * worldSize * 0.8; // Smaller spread for performance
                positions[i * 3 + 1] = Math.random() * 20 + 10;
                positions[i * 3 + 2] = (Math.random() - 0.5) * worldSize * 0.8;
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: 0x6699ff,
                size: 0.1,
                transparent: true,
                opacity: 0.6
            });
            
            rainParticles = new THREE.Points(particles, particleMaterial);
            rainParticles.visible = false;
            scene.add(rainParticles);
        }
        
        function updateRain(deltaTime) {
            const now = Date.now();
            const timeSinceLastCycle = now - lastRainCycle;
            
            // Check if it's time to start rain
            if (!isRaining && timeSinceLastCycle >= RAIN_CYCLE_DURATION) {
                isRaining = true;
                rainStartTime = now;
                lastRainCycle = now;
                rainParticles.visible = true;
                showNotification("Rain started! Seek shelter!", 3000);
            }
            
            // Check if rain should stop
            if (isRaining && (now - rainStartTime) >= RAIN_DURATION) {
                isRaining = false;
                rainParticles.visible = false;
                showNotification("Rain stopped", 2000);
            }
            
            // Update rain particles
            if (isRaining && rainParticles.visible) {
                const positions = rainParticles.geometry.attributes.position.array;
                
                for (let i = 0; i < positions.length; i += 3) {
                    // Move rain down
                    positions[i + 1] -= deltaTime * 15; // Fall speed
                    
                    // Reset to top if below ground
                    if (positions[i + 1] < 0) {
                        positions[i + 1] = 20;
                        // Re-center around player - adjusted for larger world
                        positions[i] = playerPos.x + (Math.random() - 0.5) * 40;
                        positions[i + 2] = playerPos.z + (Math.random() - 0.5) * 40;
                    }
                }
                
                rainParticles.geometry.attributes.position.needsUpdate = true;
                
                // Position rain system around player
                rainParticles.position.set(playerPos.x, 0, playerPos.z);
            }
            
            // Apply rain damage if player is exposed
            if (isRaining) {
                const isUnderShelter = checkPlayerShelter();
                
                if (!isUnderShelter) {
                    // Apply rain damage
                    health = Math.max(0, health - RAIN_DAMAGE_PER_SECOND * deltaTime);
                    updateStatsUI();
                    showDamageEffect('rain');
                    
                    if (health === 0) {
                        showGameOver("You died from exposure to rain!");
                    }
                } else {
                    // Clear damage effect when sheltered
                    if (!isNightTime) {
                        clearDamageEffect();
                    }
                }
            } else {
                // Clear rain effect when not raining
                if (!isNightTime) {
                    clearDamageEffect();
                }
            }
        }
        
        function showDamageEffect(type) {
            const overlay = document.getElementById('damageOverlay');
            if (type === 'rain') {
                overlay.style.background = 'radial-gradient(circle, transparent 40%, rgba(100, 150, 255, 0.3) 100%)';
                overlay.style.opacity = '0.7';
            } else if (type === 'night') {
                overlay.style.background = 'radial-gradient(circle, transparent 40%, rgba(70, 70, 150, 0.4) 100%)';
                overlay.style.opacity = '0.7';
            }
        }
        
        function clearDamageEffect() {
            const overlay = document.getElementById('damageOverlay');
            overlay.style.opacity = '0';
        }
        
        function checkPlayerShelter() {
            // Check if there are any blocks above the player
            const playerX = Math.floor(playerPos.x);
            const playerZ = Math.floor(playerPos.z);
            const playerY = Math.floor(playerPos.y);
            
            // Check all blocks above player up to sky
            for (let y = playerY + 1; y < worldSize; y++) {
                if (getTerrainBlock(playerX, playerZ, y) !== undefined) {
                    return true; // Found shelter
                }
            }
            
            return false; // No shelter, exposed to rain
        }
        
        function updateStatsUI() {
            const healthBar = document.getElementById('healthBar');
            const hungerBar = document.getElementById('hungerBar');
            
            healthBar.style.width = `${health}%`;
            healthBar.textContent = `${Math.round(health)}%`;
            
            // Change health bar color when low
            if (health <= 25) {
                healthBar.style.background = 'linear-gradient(to right, #c0392b, #8b0000)';
            } else if (health <= 50) {
                healthBar.style.background = 'linear-gradient(to right, #e67e22, #d35400)';
            } else {
                healthBar.style.background = 'linear-gradient(to right, #e74c3c, #c0392b)';
            }
            
            hungerBar.style.width = `${hunger}%`;
            hungerBar.textContent = `${Math.round(hunger)}%`;
            
            // Change hunger bar color when low
            if (hunger <= 25) {
                hungerBar.style.background = 'linear-gradient(to right, #d68910, #7d5306)';
            } else {
                hungerBar.style.background = 'linear-gradient(to right, #f39c12, #d68910)';
            }
        }
        
        function updateHungerAndHealth() {
            const now = Date.now();
            const timeSinceLastUpdate = (now - lastHungerUpdate) / 1000; // Convert to seconds
            
            // Update every 2 seconds
            if (timeSinceLastUpdate >= 2) {
                if (hunger > 0) {
                    // Decrease hunger by 1%
                    hunger = Math.max(0, hunger - 1);
                } else {
                    // If hunger is 0, decrease health by 1%
                    health = Math.max(0, health - 1);
                    
                    if (health === 0) {
                        showGameOver("You died from starvation!");
                    }
                }
                
                lastHungerUpdate = now;
                updateStatsUI();
            }
        }
        
        function consumeFruit() {
            if ((inventory['Fruit'] || 0) > 0) {
                inventory['Fruit']--;
                hunger = Math.min(100, hunger + 25);
                updateStatsUI();
                updateInventoryUI();
                saveGameState();
                showNotification("Ate fruit! +25% hunger");
            } else {
                showNotification("No fruit to eat!");
            }
        }
        
        function useHerb() {
            if ((inventory['Medicinal Herb'] || 0) > 0) {
                inventory['Medicinal Herb']--;
                health = Math.min(100, health + 25);
                updateStatsUI();
                updateInventoryUI();
                saveGameState();
                showNotification("Used medicinal herb! +25 HP");
            } else {
                showNotification("No medicinal herbs!");
            }
        }
        
        function eatFish() {
            if ((inventory['Fish'] || 0) > 0) {
                inventory['Fish']--;
                hunger = Math.min(100, hunger + 40);
                health = Math.min(100, health + 10);
                updateStatsUI();
                updateInventoryUI();
                saveGameState();
                showNotification("Ate fish! +40% hunger, +10 HP");
            } else {
                showNotification("No fish to eat!");
            }
        }

        function getSkillBasedDuration(skillName, baseTime = 30000) {
            const timeReductionPerLevel = 1000; // 1 second
            const level = skills[skillName] || 0;
            const duration = baseTime - (level * timeReductionPerLevel);
            return Math.max(duration, 1000); // Minimum 1 second
        }

        function levelUpSkill(skillName, amount = 1) {
            if (skills[skillName] < MAX_SKILL_LEVEL) {
                skills[skillName] += amount;
                if (skills[skillName] > MAX_SKILL_LEVEL) {
                    skills[skillName] = MAX_SKILL_LEVEL;
                }
                showNotification(`${skillName} skill increased to level ${skills[skillName]}!`);
            } else {
                showNotification(`${skillName} skill is at max level!`);
            }
            updateSkillsUI();
        }

        function startLongAction(skillName, onComplete, target = null, baseDuration = 30000) {
            if (isPerformingLongAction) return;

            isPerformingLongAction = true;
            longActionType = skillName;
            longActionStartTime = Date.now();
            longActionDuration = getSkillBasedDuration(skillName, baseDuration);
            longActionOnComplete = onComplete;

            if (skillName === 'mining' && target) {
                const blockMesh = blockMeshes[target.x]?.[target.z]?.[target.y];
                if (blockMesh) {
                    miningProgressIndicator.position.copy(blockMesh.children[4].position);
                    miningProgressIndicator.visible = true;
                    miningProgressIndicator.scale.set(0, 0, 0);
                }
            }
            
            showNotification(`Starting to ${skillName}... (${(longActionDuration/1000).toFixed(1)}s)`);
        }
        
        function createCampfire() {
            if ((inventory['Wood'] || 0) <= 0) {
                showNotification("Need wood to make fire");
                return;
            }
            
            // Place at feet
            const x = Math.floor(playerPos.x);
            const z = Math.floor(playerPos.z);
            let y = Math.floor(playerPos.y - 1.0);
            
            // Check if spot is valid (solid ground, no existing campfire)
            const groundBlock = getTerrainBlock(x, z, y);
            if (groundBlock === undefined) {
                 // Try one below
                 y--;
                 if (getTerrainBlock(x, z, y) === undefined) {
                     showNotification("Cannot place fire in air");
                     return;
                 }
            }
            
            // Check for existing campfire
            if (campfires.some(c => Math.floor(c.x) === x && Math.floor(c.z) === z && Math.floor(c.y) === y)) {
                showNotification("There is already a fire here");
                return;
            }

            inventory['Wood']--;
            updateInventoryUI();
            
            // Create visual
            const fireGeo = new THREE.PlaneGeometry(1, 1);
            const fireTex = campfireTexture.clone();
            fireTex.needsUpdate = true;
            
            // Setup spritesheet (assuming 1x5 based on common campfire assets, but if it's a single image, we might need adjustment. 
            // The prompt says "CampFireFinished_xozgsa.png". Let's assume it's a spritesheet as instantiated in init with SpriteAnimator.
            // If it's a static image, SpriteAnimator will just loop 1 frame if configured so.
            // In init we did: campfireAnimation = new SpriteAnimator(campfireTexture, 5, 1, 0.15);
            // We need to clone this animator for each instance OR share it?
            // Actually, SpriteAnimator modifies texture offset. So we need independent textures/animators per instance
            // OR we render all fires with the same animation phase (sync). Sync is cheaper.
            
            fireTex.wrapS = THREE.RepeatWrapping;
            fireTex.wrapT = THREE.RepeatWrapping;
            fireTex.repeat.set(1/5, 1); // 5 frames horizontal
            
            const fireMat = new THREE.MeshBasicMaterial({
                map: fireTex,
                transparent: true,
                side: THREE.FrontSide,
                depthWrite: false
            });
            
            const fireMesh = new THREE.Mesh(fireGeo, fireMat);
            fireMesh.position.set(x + 0.5, y + 1.5, z + 0.5);
            
            // Group for wrapping
            const fireGroup = new THREE.Group();
            for (let offsetX = -1; offsetX <= 1; offsetX++) {
                for (let offsetZ = -1; offsetZ <= 1; offsetZ++) {
                    const copy = fireMesh.clone();
                    copy.material = fireMat.clone(); // Clone material to allow independent offset if we wanted, but we can sync them.
                    // Actually for sync, we can share material if we update the shared texture offset? 
                    // No, ThreeJS texture offset is per texture instance.
                    // Let's create a new material but use the same texture logic.
                    
                    copy.position.set(x + 0.5 + offsetX * worldSize, y + 1.5, z + 0.5 + offsetZ * worldSize);
                    fireGroup.add(copy);
                }
            }
            scene.add(fireGroup);
            
            campfires.push({
                x: x + 0.5, y, z: z + 0.5,
                group: fireGroup,
                creationTime: Date.now(),
                animator: new SpriteAnimator(fireTex, 5, 1, 0.15) // Each fire needs its own animator to control its texture
            });
            
            // We need to apply the animator to ALL copies in the group.
            // The animator in the object controls 'fireTex'. 
            // But we cloned materials for copies.
            // Let's simplify: 1 animator per fire instance. The animator updates 'fireTex'.
            // The copies need to share 'fireTex' or we need to update all their textures.
            // In the loop above: `copy.material = fireMat.clone();` -> uses `fireTex` (cloned).
            // Wait, `fireTex = campfireTexture.clone()`.
            // So `fireMat` uses `fireTex`.
            // `copy.material` uses `fireTex`. 
            // So updating `fireTex` updates all copies. Great.
            
            showNotification("Campfire created!");
        }

        function updateCampfires(deltaTime) {
            campfires.forEach(fire => {
                fire.animator.update(deltaTime);
                
                // Billboard
                fire.group.children.forEach(mesh => {
                     const angle = Math.atan2(
                        camera.position.x - mesh.position.x,
                        camera.position.z - mesh.position.z
                    );
                    mesh.rotation.y = angle;
                });
            });
        }

        function updateLongAction() {
            if (!isPerformingLongAction) return;

            const elapsedTime = Date.now() - longActionStartTime;
            const progress = elapsedTime / longActionDuration;

            if (longActionType === 'mining') {
                const scale = Math.min(progress, 1.0);
                miningProgressIndicator.scale.set(scale, scale, scale);
            }

            // TODO: Update progress bar UI

            if (progress >= 1) {
                isPerformingLongAction = false;
                
                if (longActionType === 'mining') {
                    miningProgressIndicator.visible = false;
                }
                
                if (longActionOnComplete) {
                    longActionOnComplete();
                }
                
                if (longActionType !== 'fighting') {
                    levelUpSkill(longActionType);
                }
            }
        }


        function validateTrees() {
            // Check all trees and remove any that are floating (no soil beneath)
            for (let i = trees.length - 1; i >= 0; i--) {
                const tree = trees[i];
                const x = Math.round(tree.x);
                const z = Math.round(tree.z);
                
                // Check if there's a solid block (preferably soil) directly beneath the tree
                let hasGroundBeneath = false;
                if (terrain[x] && terrain[x][z]) {
                    // The tree should be standing on the block at tree.y - 1
                    const groundY = tree.y - 1;
                    if (groundY >= 0 && terrain[x][z][groundY] !== undefined) {
                        // Check if it's soil (preferred) or at least some solid block
                        if (terrain[x][z][groundY] === MATERIALS.SOIL.id) {
                            hasGroundBeneath = true;
                        } else {
                            // Even if not soil, if there's a solid block chain down to soil, it's okay
                            let foundSoilBelow = false;
                            for (let y = groundY; y >= 0; y--) {
                                if (terrain[x][z][y] === undefined) break; // Gap found
                                if (terrain[x][z][y] === MATERIALS.SOIL.id) {
                                    foundSoilBelow = true;
                                    break;
                                }
                            }
                            hasGroundBeneath = foundSoilBelow;
                        }
                    }
                }
                
                // Remove tree if no proper ground found
                if (!hasGroundBeneath) {
                    scene.remove(tree.group);
                    trees.splice(i, 1);
                }
            }
            console.log(`Validated trees: ${trees.length} trees remaining`);
        }
        
        function createHealthBar() {
            const healthBarGeo = new THREE.PlaneGeometry(1, 0.1);
            const healthBarMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const healthBar = new THREE.Mesh(healthBarGeo, healthBarMat);
            healthBar.position.y = 1; // Position it above the animal
            return healthBar;
        }

        function generateBears() {
            const numBears = 5; // Spawn 5 bears
            const placedPositions = new Set();
            
            for (let i = 0; i < numBears; i++) {
                let x, z, topY;
                let attempts = 0;
                
                do {
                    x = Math.floor(Math.random() * worldSize);
                    z = Math.floor(Math.random() * worldSize);
                    attempts++;
                    
                    if (attempts > 100) break;
                    if (placedPositions.has(`${x},${z}`)) continue;
                    
                    // Find top terrain height
                    if (!terrain[x] || !terrain[x][z]) continue;
                    for (let y = worldSize - 1; y >= 0; y--) {
                        if (terrain[x][z][y] !== undefined) {
                            topY = y;
                            break;
                        }
                    }
                } while (!topY || terrain[x][z][topY] !== MATERIALS.SOIL.id);
                
                placedPositions.add(`${x},${z}`);
                
                // Create bear sprite
                const bearGeo = new THREE.PlaneGeometry(1.2, 1.2);
                
                // Bear spritesheet is 4 columns x 4 rows (front, side, back, side views)
                const bearTex = bearTexture.clone();
                bearTex.needsUpdate = true;
                bearTex.wrapS = THREE.RepeatWrapping;
                bearTex.wrapT = THREE.RepeatWrapping;
                const frameW = 1 / 4;
                const frameH = 1 / 4;
                bearTex.repeat.set(frameW, frameH);
                bearTex.offset.set(0, 1 - frameH); // Start with front view
                
                const bearMat = new THREE.MeshBasicMaterial({
                    map: bearTex,
                    transparent: true,
                    side: THREE.FrontSide,
                    depthTest: true,
                    depthWrite: false
                });
                
                const bearPos = new THREE.Vector3(x + 0.5, topY + 1.6, z + 0.5);
                
                const bearVisuals = new THREE.Group();
                for (let offsetX = -1; offsetX <= 1; offsetX++) {
                    for (let offsetZ = -1; offsetZ <= 1; offsetZ++) {
                        const bearMesh = new THREE.Mesh(bearGeo, bearMat.clone());
                        bearMesh.position.set(
                            x + 0.5 + offsetX * worldSize,
                            topY + 1.6,
                            z + 0.5 + offsetZ * worldSize
                        );
                        bearVisuals.add(bearMesh);
                    }
                }

                const healthBar = createHealthBar();
                healthBar.visible = false;

                const bearGroup = new THREE.Group();
                bearGroup.add(bearVisuals);
                bearGroup.add(healthBar);
                scene.add(bearGroup);
                
                bears.push({
                    group: bearGroup,
                    visuals: bearVisuals,
                    mesh: bearVisuals.children[4], // Center copy
                    healthBar: healthBar,
                    position: bearPos,
                    x: x + 0.5,
                    z: z + 0.5,
                    wanderDirection: new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize(),
                    wanderTimer: Math.random() * 3000,
                    state: 'wander', // 'wander' or 'chase'
                    lastAttackTime: 0,
                    currentFrame: 0,
                    animationTimer: 0,
                    health: BEAR_MAX_HEALTH,
                    isDying: false,
                    deathProgress: 0
                });
            }
            console.log(`Spawned ${bears.length} bears`);
        }
        
        function updateBears(deltaTime) {
            const now = Date.now();
            
            for (let i = bears.length - 1; i >= 0; i--) {
                const bear = bears[i];
                
                // Handle death animation
                if (bear.isDying) {
                    bear.deathProgress += deltaTime * 2;
                    
                    // Flip upside down and fade
                    for (const bearCopy of bear.visuals.children) {
                        bearCopy.rotation.z = Math.PI * bear.deathProgress; // Flip
                        bearCopy.material.opacity = Math.max(0, 1 - bear.deathProgress);
                    }
                    
                    if (bear.deathProgress >= 1) {
                        scene.remove(bear.group);
                        bears.splice(i, 1);
                    }
                    continue;
                }
                
                // Store old position to calculate movement direction
                const oldX = bear.position.x;
                const oldZ = bear.position.z;
                
                // Calculate distance to player (with wrapping)
                const distanceToPlayer = getWrappedDistance(
                    bear.position.x, bear.position.z,
                    playerPos.x, playerPos.z
                );

                // Health bar visibility
                bear.healthBar.visible = distanceToPlayer < BEAR_CHASE_DISTANCE;
                
                // Update bear state
                if (distanceToPlayer < BEAR_CHASE_DISTANCE) {
                    bear.state = 'chase';
                } else {
                    bear.state = 'wander';
                }
                
                let moveDirection = new THREE.Vector3();
                
                // Bear AI behavior
                if (bear.state === 'chase') {
                    // Chase player using wrapped direction
                    const dirToPlayer = getWrappedDirection(
                        bear.position.x, bear.position.z,
                        playerPos.x, playerPos.z
                    );
                    
                    if (distanceToPlayer > BEAR_ATTACK_DISTANCE) {
                        bear.position.x += dirToPlayer.x * BEAR_SPEED;
                        bear.position.z += dirToPlayer.z * BEAR_SPEED;
                    }
                    moveDirection.copy(dirToPlayer);
                    
                    // Attack if close enough
                    if (distanceToPlayer < BEAR_ATTACK_DISTANCE) {
                        if (now - bear.lastAttackTime > BEAR_ATTACK_COOLDOWN) {
                            health = Math.max(0, health - BEAR_ATTACK_DAMAGE);
                            bear.lastAttackTime = now;
                            updateStatsUI();
                            showNotification("Bear attacked! -5 HP", 1000);
                            
                            if (health === 0) {
                                showGameOver("You were killed by a bear!");
                            }
                        }
                    }
                } else {
                    // Random wandering
                    bear.wanderTimer -= deltaTime * 1000;
                    if (bear.wanderTimer <= 0) {
                        // Change direction
                        bear.wanderDirection = new THREE.Vector3(
                            Math.random() - 0.5, 0, Math.random() - 0.5
                        ).normalize();
                        bear.wanderTimer = 2000 + Math.random() * 3000; // 2-5 seconds
                    }
                    
                    bear.position.x += bear.wanderDirection.x * BEAR_SPEED * 0.5; // Slower when wandering
                    bear.position.z += bear.wanderDirection.z * BEAR_SPEED * 0.5;
                    moveDirection.copy(bear.wanderDirection);
                }
                
                // Wrap bears around world boundaries
                if (bear.position.x < 0) bear.position.x += worldSize;
                if (bear.position.x >= worldSize) bear.position.x -= worldSize;
                if (bear.position.z < 0) bear.position.z += worldSize;
                if (bear.position.z >= worldSize) bear.position.z -= worldSize;
                
                // Update bear's Y position to stand on terrain (with wrapping)
                let bearGroundHeight = 0;
                for (let y = worldSize - 1; y >= 0; y--) {
                    if (getTerrainBlock(Math.floor(bear.position.x), Math.floor(bear.position.z), y) !== undefined) {
                        bearGroundHeight = y + 1;
                        break;
                    }
                }
                bear.position.y = bearGroundHeight + 0.6;
                
                // Update all 9 copies of the bear
                let copyIndex = 0;
                for (const bearCopy of bear.visuals.children) {
                    bearCopy.position.set(
                        bear.position.x + (copyIndex % 3 - 1) * worldSize,
                        bear.position.y,
                        bear.position.z + (Math.floor(copyIndex / 3) - 1) * worldSize
                    );
                    // Make parallel to viewing plane
                    const angle = Math.atan2(
                        camera.position.x - bearCopy.position.x,
                        camera.position.z - bearCopy.position.z
                    );
                    bearCopy.rotation.y = angle;
                    copyIndex++;
                }

                // Update health bar position and rotation
                bear.healthBar.position.set(bear.position.x, bear.position.y + 1.0, bear.position.z);
                const angle = Math.atan2(
                    camera.position.x - bear.healthBar.position.x,
                    camera.position.z - bear.healthBar.position.z
                );
                bear.healthBar.rotation.y = angle;
                
                // Determine which direction row to use based on movement relative to camera
                let directionRow = 0; // Default to front
                if (moveDirection.lengthSq() > 0) {
                    // Get camera's forward vector (direction from player to camera)
                    const cameraForward = new THREE.Vector3();
                    cameraForward.subVectors(camera.position, playerPos).normalize();
                    cameraForward.y = 0;
                    cameraForward.normalize();
                    
                    // Get camera's right vector
                    const cameraRight = new THREE.Vector3();
                    cameraRight.crossVectors(cameraForward, new THREE.Vector3(0, 1, 0)).normalize();
                    
                    // Calculate dot products to determine direction
                    const dotForward = moveDirection.dot(cameraForward);
                    const dotRight = moveDirection.dot(cameraRight);
                    
                    // Determine which row to use based on actual spritesheet layout
                    // Row 0: Front, Row 1: Left, Row 2: Back, Row 3: Right
                    if (Math.abs(dotForward) > Math.abs(dotRight)) {
                        // Moving mostly forward/backward relative to camera
                        if (dotForward > 0) {
                            directionRow = 0; // Front - moving toward camera
                        } else {
                            directionRow = 3; // Back - moving away from camera
                        }
                    } else {
                        // Moving mostly left/right relative to camera
                        if (dotRight > 0) {
                            directionRow = 1; // Right side
                        } else {
                            directionRow = 2; // Left side
                        }
                    }
                }
                
                // Animate bear sprite
                bear.animationTimer += deltaTime;
                if (bear.animationTimer > 0.15) {
                    bear.currentFrame = (bear.currentFrame + 1) % 4; // 4 frames per row
                    bear.animationTimer = 0;
                }
                
                // Update texture offset for animation and direction on all 9 copies
                const frameW = 1 / 4;
                const frameH = 1 / 4;
                for (const bearCopy of bear.visuals.children) {
                    bearCopy.material.map.repeat.set(frameW, frameH);
                    bearCopy.material.map.offset.x = bear.currentFrame * frameW;
                    bearCopy.material.map.offset.y = 1 - (directionRow + 1) * frameH;
                }
            }
        }

        function generateWolves() {
            const numWolves = 10; // More wolves than bears
            const placedPositions = new Set();
            
            for (let i = 0; i < numWolves; i++) {
                let x, z, topY;
                let attempts = 0;
                
                do {
                    x = Math.floor(Math.random() * worldSize);
                    z = Math.floor(Math.random() * worldSize);
                    attempts++;
                    
                    if (attempts > 100) break;
                    if (placedPositions.has(`${x},${z}`)) continue;
                    
                    // Find top terrain height
                    if (!terrain[x] || !terrain[x][z]) continue;
                    for (let y = worldSize - 1; y >= 0; y--) {
                        if (terrain[x][z][y] !== undefined) {
                            topY = y;
                            break;
                        }
                    }
                } while (!topY || terrain[x][z][topY] !== MATERIALS.SOIL.id);
                
                placedPositions.add(`${x},${z}`);
                
                // Create wolf sprite
                const wolfGeo = new THREE.PlaneGeometry(0.9, 0.9); // Smaller than bears
                
                // Wolf spritesheet is 3 columns x 4 rows
                const wolfTex = wolfTexture.clone();
                wolfTex.needsUpdate = true;
                wolfTex.wrapS = THREE.RepeatWrapping;
                wolfTex.wrapT = THREE.RepeatWrapping;
                const frameW = 1 / 3; // 3 columns
                const frameH = 1 / 4; // 4 rows
                wolfTex.repeat.set(frameW, frameH);
                wolfTex.offset.set(0, 1 - frameH); // Start with front view
                
                const wolfMat = new THREE.MeshBasicMaterial({
                    map: wolfTex,
                    transparent: true,
                    side: THREE.FrontSide,
                    depthTest: true,
                    depthWrite: false
                });
                
                const wolfPos = new THREE.Vector3(x + 0.5, topY + 1.45, z + 0.5);
                
                const wolfVisuals = new THREE.Group();
                for (let offsetX = -1; offsetX <= 1; offsetX++) {
                    for (let offsetZ = -1; offsetZ <= 1; offsetZ++) {
                        const wolfMesh = new THREE.Mesh(wolfGeo, wolfMat.clone());
                        wolfMesh.position.set(
                            x + 0.5 + offsetX * worldSize,
                            topY + 1.45,
                            z + 0.5 + offsetZ * worldSize
                        );
                        wolfVisuals.add(wolfMesh);
                    }
                }
                
                const healthBar = createHealthBar();
                healthBar.visible = false;

                const wolfGroup = new THREE.Group();
                wolfGroup.add(wolfVisuals);
                wolfGroup.add(healthBar);
                scene.add(wolfGroup);
                
                wolves.push({
                    group: wolfGroup,
                    visuals: wolfVisuals,
                    mesh: wolfVisuals.children[4], // Center copy
                    healthBar: healthBar,
                    position: wolfPos,
                    x: x + 0.5,
                    z: z + 0.5,
                    wanderDirection: new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize(),
                    wanderTimer: Math.random() * 3000,
                    state: 'wander',
                    lastAttackTime: 0,
                    currentFrame: 0,
                    animationTimer: 0,
                    health: WOLF_MAX_HEALTH,
                    isDying: false,
                    deathProgress: 0
                });
            }
            console.log(`Spawned ${wolves.length} wolves`);
        }
        
        function updateWolves(deltaTime) {
            const now = Date.now();
            
            for (let i = wolves.length - 1; i >= 0; i--) {
                const wolf = wolves[i];
                
                // Handle death animation
                if (wolf.isDying) {
                    wolf.deathProgress += deltaTime * 2;
                    
                    // Flip upside down and fade
                    for (const wolfCopy of wolf.visuals.children) {
                        wolfCopy.rotation.z = Math.PI * wolf.deathProgress; // Flip
                        wolfCopy.material.opacity = Math.max(0, 1 - wolf.deathProgress);
                    }
                    
                    if (wolf.deathProgress >= 1) {
                        scene.remove(wolf.group);
                        wolves.splice(i, 1);
                    }
                    continue;
                }
                
                // Calculate distance to player (with wrapping)
                const distanceToPlayer = getWrappedDistance(
                    wolf.position.x, wolf.position.z,
                    playerPos.x, playerPos.z
                );
                
                // Health bar visibility
                wolf.healthBar.visible = distanceToPlayer < WOLF_CHASE_DISTANCE;

                // Update wolf state
                if (distanceToPlayer < WOLF_CHASE_DISTANCE) {
                    wolf.state = 'chase';
                } else {
                    wolf.state = 'wander';
                }
                
                let moveDirection = new THREE.Vector3();
                
                // Wolf AI behavior
                if (wolf.state === 'chase') {
                    // Chase player using wrapped direction
                    const dirToPlayer = getWrappedDirection(
                        wolf.position.x, wolf.position.z,
                        playerPos.x, playerPos.z
                    );
                    
                    if (distanceToPlayer > WOLF_ATTACK_DISTANCE) {
                        wolf.position.x += dirToPlayer.x * WOLF_SPEED;
                        wolf.position.z += dirToPlayer.z * WOLF_SPEED;
                    }
                    moveDirection.copy(dirToPlayer);
                    
                    // Attack if close enough
                    if (distanceToPlayer < WOLF_ATTACK_DISTANCE) {
                        if (now - wolf.lastAttackTime > WOLF_ATTACK_COOLDOWN) {
                            health = Math.max(0, health - WOLF_ATTACK_DAMAGE);
                            wolf.lastAttackTime = now;
                            updateStatsUI();
                            showNotification("Wolf attacked! -2 HP", 1000);
                            
                            if (health === 0) {
                                showGameOver("You were killed by wolves!");
                            }
                        }
                    }
                } else {
                    // Random wandering
                    wolf.wanderTimer -= deltaTime * 1000;
                    if (wolf.wanderTimer <= 0) {
                        // Change direction
                        wolf.wanderDirection = new THREE.Vector3(
                            Math.random() - 0.5, 0, Math.random() - 0.5
                        ).normalize();
                        wolf.wanderTimer = 1500 + Math.random() * 2500; // 1.5-4 seconds (faster changes)
                    }
                    
                    wolf.position.x += wolf.wanderDirection.x * WOLF_SPEED * 0.6; // Faster wandering than bears
                    wolf.position.z += wolf.wanderDirection.z * WOLF_SPEED * 0.6;
                    moveDirection.copy(wolf.wanderDirection);
                }
                
                // Wrap wolves around world boundaries
                if (wolf.position.x < 0) wolf.position.x += worldSize;
                if (wolf.position.x >= worldSize) wolf.position.x -= worldSize;
                if (wolf.position.z < 0) wolf.position.z += worldSize;
                if (wolf.position.z >= worldSize) wolf.position.z -= worldSize;
                
                // Update wolf's Y position to stand on terrain (with wrapping)
                let wolfGroundHeight = 0;
                for (let y = worldSize - 1; y >= 0; y--) {
                    if (getTerrainBlock(Math.floor(wolf.position.x), Math.floor(wolf.position.z), y) !== undefined) {
                        wolfGroundHeight = y + 1;
                        break;
                    }
                }
                wolf.position.y = wolfGroundHeight + 0.45;
                
                // Update all 9 copies of the wolf
                let copyIndex = 0;
                for (const wolfCopy of wolf.visuals.children) {
                    wolfCopy.position.set(
                        wolf.position.x + (copyIndex % 3 - 1) * worldSize,
                        wolf.position.y,
                        wolf.position.z + (Math.floor(copyIndex / 3) - 1) * worldSize
                    );
                    // Make parallel to viewing plane
                    const angle = Math.atan2(
                        camera.position.x - wolfCopy.position.x,
                        camera.position.z - wolfCopy.position.z
                    );
                    wolfCopy.rotation.y = angle;
                    copyIndex++;
                }

                // Update health bar position and rotation
                wolf.healthBar.position.set(wolf.position.x, wolf.position.y + 0.8, wolf.position.z);
                const angle = Math.atan2(
                    camera.position.x - wolf.healthBar.position.x,
                    camera.position.z - wolf.healthBar.position.z
                );
                wolf.healthBar.rotation.y = angle;
                
                // Determine which direction row to use based on movement relative to camera
                let directionRow = 0; // Default to front
                if (moveDirection.lengthSq() > 0) {
                    // Get camera's forward vector
                    const cameraForward = new THREE.Vector3();
                    cameraForward.subVectors(camera.position, playerPos).normalize();
                    cameraForward.y = 0;
                    cameraForward.normalize();
                    
                    // Get camera's right vector
                    const cameraRight = new THREE.Vector3();
                    cameraRight.crossVectors(cameraForward, new THREE.Vector3(0, 1, 0)).normalize();
                    
                    // Calculate dot products to determine direction
                    const dotForward = moveDirection.dot(cameraForward);
                    const dotRight = moveDirection.dot(cameraRight);
                    
                    // Determine which row to use based on spritesheet layout
                    // Row 0: Front, Row 1: Left, Row 2: Back, Row 3: Right
                    if (Math.abs(dotForward) > Math.abs(dotRight)) {
                        if (dotForward > 0) {
                            directionRow = 0; // Front
                        } else {
                            directionRow = 3; // Back
                        }
                    } else {
                        if (dotRight > 0) {
                            directionRow = 1; // Right
                        } else {
                            directionRow = 2; // Left
                        }
                    }
                }
                
                // Animate wolf sprite (faster animation)
                wolf.animationTimer += deltaTime;
                if (wolf.animationTimer > 0.12) { // Faster animation than bears
                    wolf.currentFrame = (wolf.currentFrame + 1) % 3; // 3 frames per row
                    wolf.animationTimer = 0;
                }
                
                // Update texture offset for animation and direction on all 9 copies
                const frameW = 1 / 3; // 3 columns
                const frameH = 1 / 4; // 4 rows
                for (const wolfCopy of wolf.visuals.children) {
                    wolfCopy.material.map.repeat.set(frameW, frameH);
                    wolfCopy.material.map.offset.x = wolf.currentFrame * frameW;
                    wolfCopy.material.map.offset.y = 1 - (directionRow + 1) * frameH;
                }
            }
        }

        function generateBushes() {
            const numBushes = 300; // Triple the bushes for 3x larger world
            const placedPositions = new Set();
            
            for (let i = 0; i < numBushes; i++) {
                let x, z, topY;
                let attempts = 0;
                
                do {
                    x = Math.floor(Math.random() * worldSize);
                    z = Math.floor(Math.random() * worldSize);
                    attempts++;
                    
                    if (attempts > 100) break;
                    if (placedPositions.has(`${x},${z}`)) continue;
                    
                    // Find top terrain height
                    if (!terrain[x] || !terrain[x][z]) continue;
                    for (let y = worldSize - 1; y >= 0; y--) {
                        if (terrain[x][z][y] !== undefined) {
                            topY = y;
                            break;
                        }
                    }
                } while (!topY || terrain[x][z][topY] !== MATERIALS.SOIL.id);
                
                placedPositions.add(`${x},${z}`);
                
                // Randomly select bush type (0-4)
                const bushType = Math.floor(Math.random() * 5);
                const isMedicinalHerb = (bushType === MEDICINAL_HERB_BUSH_INDEX);
                
                // Create bush sprite - spritesheet is 1 column x 5 rows
                const bushGeo = new THREE.PlaneGeometry(1.0, 1.0);
                const bushTex = bushTexture.clone();
                bushTex.needsUpdate = true;
                bushTex.wrapS = THREE.RepeatWrapping;
                bushTex.wrapT = THREE.RepeatWrapping;
                const frameH = 1 / 5; // 5 rows
                bushTex.repeat.set(1, frameH);
                bushTex.offset.set(0, 1 - (bushType + 1) * frameH);
                
                const bushMat = new THREE.MeshBasicMaterial({
                    map: bushTex,
                    transparent: true,
                    side: THREE.FrontSide,
                    depthTest: true,
                    depthWrite: false
                });
                
                const bushPos = new THREE.Vector3(x + 0.5, topY + 1.0, z + 0.5);
                
                // Create 9 copies for seamless wrapping
                const bushGroup = new THREE.Group();
                for (let offsetX = -1; offsetX <= 1; offsetX++) {
                    for (let offsetZ = -1; offsetZ <= 1; offsetZ++) {
                        const bushMesh = new THREE.Mesh(bushGeo, bushMat.clone());
                        bushMesh.position.set(
                            x + 0.5 + offsetX * worldSize,
                            topY + 1.0,
                            z + 0.5 + offsetZ * worldSize
                        );
                        bushGroup.add(bushMesh);
                    }
                }
                scene.add(bushGroup);
                
                bushes.push({
                    group: bushGroup,
                    mesh: bushGroup.children[4], // Center copy
                    position: bushPos,
                    x: x + 0.5,
                    z: z + 0.5,
                    y: topY,
                    type: bushType,
                    isMedicinalHerb: isMedicinalHerb,
                    harvested: false,
                    harvestTime: null
                });
            }
            console.log(`Spawned ${bushes.length} bushes (${bushes.filter(b => b.isMedicinalHerb).length} medicinal herbs)`);
        }
        
        function updateBushes() {
            const now = Date.now();
            
            for (const bush of bushes) {
                // Make bushes parallel to viewing plane
                for (const bushCopy of bush.group.children) {
                    // Calculate rotation to face camera (Y-axis only)
                    const angle = Math.atan2(
                        camera.position.x - bushCopy.position.x,
                        camera.position.z - bushCopy.position.z
                    );
                    bushCopy.rotation.y = angle;
                }
                
                // Handle herb regrowth
                if (bush.isMedicinalHerb && bush.harvested && bush.harvestTime) {
                    const timeSinceHarvest = now - bush.harvestTime;
                    if (timeSinceHarvest >= HERB_REGROW_TIME) {
                        // Regrow after 5 minutes
                        bush.harvested = false;
                        bush.harvestTime = null;
                        // Make bush visible again
                        bush.group.visible = true;
                    } else {
                        // Hide while regrowing
                        bush.group.visible = false;
                    }
                }
            }
        }
        
        function harvestHerbInDirection() {
            if (playerLastMoveDirection.lengthSq() === 0) {
                showNotification("Move first to target a bush");
                return;
            }

            const playerX = Math.round(playerPos.x);
            const playerZ = Math.round(playerPos.z);

            const dirX = Math.round(playerLastMoveDirection.x);
            const dirZ = Math.round(playerLastMoveDirection.z);

            const targetX = playerX + dirX;
            const targetZ = playerZ + dirZ;

            // Find medicinal herb bush at target position
            const bushIndex = bushes.findIndex(bush => 
                Math.round(bush.x) === targetX && 
                Math.round(bush.z) === targetZ &&
                bush.isMedicinalHerb &&
                !bush.harvested
            );

            if (bushIndex !== -1) {
                const bush = bushes[bushIndex];
                
                // Add medicinal herb to inventory
                inventory['Medicinal Herb'] = (inventory['Medicinal Herb'] || 0) + 1;
                
                // Mark as harvested
                bush.harvested = true;
                bush.harvestTime = Date.now();
                bush.group.visible = false;
                
                showNotification("Harvested Medicinal Herb!");
                updateInventoryUI();
            } else {
                showNotification("No medicinal herbs to harvest");
            }
        }
        
        function plantBush() {
            if (!plantingBushSeeds) {
                showNotification("Select bush seeds to plant");
                return;
            }
            
            if ((inventory['Bush Seeds'] || 0) <= 0) {
                showNotification("No bush seeds in inventory");
                return;
            }
            
            if (playerLastMoveDirection.lengthSq() === 0) {
                showNotification("Move first to target a spot");
                return;
            }

            const playerX = Math.round(playerPos.x);
            const playerZ = Math.round(playerPos.z);
            const dirX = Math.round(playerLastMoveDirection.x);
            const dirZ = Math.round(playerLastMoveDirection.z);
            
            const targetX = playerX + dirX;
            const targetZ = playerZ + dirZ;
            
            // Check if position is valid
            if (targetX < 0 || targetX >= worldSize || targetZ < 0 || targetZ >= worldSize) {
                showNotification("Cannot plant outside world boundaries");
                return;
            }
            
            // Check if there's already a bush at this position
            const existingBush = bushes.find(bush => {
                const distance = Math.sqrt((targetX - bush.x + 0.5) ** 2 + (targetZ - bush.z + 0.5) ** 2);
                return distance < 1.5;
            });
            if (existingBush) {
                showNotification("Too close to another bush");
                return;
            }
            
            // Find the top terrain height at target position
            let topY = 0;
            if (terrain[targetX] && terrain[targetX][targetZ]) {
                for (let y = worldSize - 1; y >= 0; y--) {
                    if (terrain[targetX][targetZ][y] !== undefined) {
                        topY = y;
                        break;
                    }
                }
            }
            
            // Check if the top block is soil
            if (topY === 0 || (terrain[targetX] && terrain[targetX][targetZ] && 
                terrain[targetX][targetZ][topY] !== MATERIALS.SOIL.id)) {
                showNotification("Can only plant bushes on soil");
                return;
            }
            
            // Consume seed
            inventory['Bush Seeds']--;
            
            // Randomly select bush type (0-4)
            const bushType = Math.floor(Math.random() * 5);
            const isMedicinalHerb = (bushType === MEDICINAL_HERB_BUSH_INDEX);
            
            // Create bush sprite
            const bushGeo = new THREE.PlaneGeometry(1.0, 1.0);
            const bushTex = bushTexture.clone();
            bushTex.needsUpdate = true;
            bushTex.wrapS = THREE.RepeatWrapping;
            bushTex.wrapT = THREE.RepeatWrapping;
            const frameH = 1 / 5;
            bushTex.repeat.set(1, frameH);
            bushTex.offset.set(0, 1 - (bushType + 1) * frameH);
            
            const bushMat = new THREE.MeshBasicMaterial({
                map: bushTex,
                transparent: true,
                side: THREE.FrontSide,
                depthTest: true,
                depthWrite: false
            });
            
            const bushPos = new THREE.Vector3(targetX + 0.5, topY + 1.0, targetZ + 0.5);
            
            // Create 9 copies for seamless wrapping
            const bushGroup = new THREE.Group();
            for (let offsetX = -1; offsetX <= 1; offsetX++) {
                for (let offsetZ = -1; offsetZ <= 1; offsetZ++) {
                    const bushMesh = new THREE.Mesh(bushGeo, bushMat.clone());
                    bushMesh.position.set(
                        targetX + 0.5 + offsetX * worldSize,
                        topY + 1.0,
                        targetZ + 0.5 + offsetZ * worldSize
                    );
                    bushGroup.add(bushMesh);
                }
            }
            scene.add(bushGroup);
            
            bushes.push({
                group: bushGroup,
                mesh: bushGroup.children[4],
                position: bushPos,
                x: targetX + 0.5,
                z: targetZ + 0.5,
                y: topY,
                type: bushType,
                isMedicinalHerb: isMedicinalHerb,
                harvested: false,
                harvestTime: null
            });
            
            updateInventoryUI();
            showNotification("Planted a bush!");
        }

     function generateTrees(treeTexture) {
    const numTrees = 600; // Triple the trees for 3x larger world
    const placedPositions = new Set();
    const minTreeDistance = 2; // Minimum distance between trees

    for (let i = 0; i < numTrees; i++) {
        let x, z, topY;
        let attempts = 0;

        do {
            x = Math.floor(Math.random() * worldSize);
            z = Math.floor(Math.random() * worldSize);
            attempts++;

            if (attempts > 100) return; // give up

            if (placedPositions.has(`${x},${z}`)) continue;

            // Check minimum distance from other trees
            let tooClose = false;
            for (const pos of placedPositions) {
                const [placedX, placedZ] = pos.split(',').map(Number);
                const distance = Math.sqrt((x - placedX) ** 2 + (z - placedZ) ** 2);
                if (distance < minTreeDistance) {
                    tooClose = true;
                    break;
                }
            }
            if (tooClose) continue;

            if (!terrain[x] || !terrain[x][z]) continue;
            for (let y = worldSize - 1; y >= 0; y--) {
                if (terrain[x][z][y] !== undefined) {
                    topY = y;
                    break;
                }
            }
        } while (!topY || terrain[x][z][topY] !== MATERIALS.SOIL.id);

        placedPositions.add(`${x},${z}`);

        // pick tree type
        const treeType = Math.floor(Math.random() * TREE_TYPES.length);
        const treeData = TREE_TYPES[treeType];

        // build the tree
        const treeGroup = createTreeMesh(treeType);
        
        // Add random size variation (70% to 130% of base size)
        const sizeVariation = 0.7 + Math.random() * 0.6;
        treeGroup.scale.set(sizeVariation, sizeVariation, 1);
        
        const treeParent = new THREE.Group();
        for (let offsetX = -1; offsetX <= 1; offsetX++) {
            for (let offsetZ = -1; offsetZ <= 1; offsetZ++) {
                const treeCopy = treeGroup.clone();
                treeCopy.position.set(x + offsetX * worldSize, topY + 0.5, z + offsetZ * worldSize);
                treeParent.add(treeCopy);
            }
        }
        scene.add(treeParent);

        // 20% chance to be a fruit tree
        const isFruitTree = Math.random() < 0.2;
        const fruitCount = isFruitTree ? (1 + Math.floor(Math.random() * 6)) : 0; // 1..6
        
        // If this is a fruit tree, swap to fruit texture for all copies
        if (isFruitTree) {
            for (const treeCopy of treeParent.children) {
                updateTreeTexture(treeCopy.children[0], treeType, true);
            }
        }

        trees.push({
            x, z, y: topY,  // Store the position at terrain level
            position: new THREE.Vector3(x + 0.5, topY + 3.0, z + 0.5),
            type: treeType,
            group: treeParent,
            mesh: treeParent.children[4].children[0], // Center copy (index 4 in 3x3 grid)
            wood:  treeData.minWood  + Math.floor(Math.random() * (treeData.maxWood  - treeData.minWood  + 1)),
            seeds: treeData.minSeeds + Math.floor(Math.random() * (treeData.maxSeeds - treeData.minSeeds + 1)),
            isFalling: false,
            fallProgress: 0,
            fallDirection: 1,
            plantedTime: Date.now() - 600000,
            growthStage: 10,
            sizeVariation: sizeVariation, // Store the random size for growth calculations
            // fruit metadata
            isFruitTree,
            fruit: fruitCount,
            fruitPicked: false,
            fruitPickTime: null,
            maxFruit: fruitCount
        });
    }
}
//createTreeMesh
        function createPlayer() {
            // Find a suitable spawn location away from water
            // Start at a random position instead of always center
            let spawnX = Math.floor(Math.random() * worldSize);
            let spawnZ = Math.floor(Math.random() * worldSize);
            let foundSuitableSpawn = false;
            let attempts = 0;
            const maxAttempts = 200; // Increased attempts for better success rate
            
            // Search for a suitable spawn location
            while (!foundSuitableSpawn && attempts < maxAttempts) {
                // Check a spiral pattern from the random starting point
                const angle = (attempts * 0.5) % (Math.PI * 2);
                const radius = Math.floor(attempts / 6) + 1;
                
                spawnX = Math.floor(spawnX + Math.cos(angle) * radius);
                spawnZ = Math.floor(spawnZ + Math.sin(angle) * radius);
                
                // Wrap coordinates
                spawnX = ((spawnX % worldSize) + worldSize) % worldSize;
                spawnZ = ((spawnZ % worldSize) + worldSize) % worldSize;
                
                // Find the terrain height at this position
                let groundY = 0;
                if (terrain[spawnX] && terrain[spawnX][spawnZ]) {
                    for (let y = worldSize - 1; y >= 0; y--) {
                        if (terrain[spawnX][spawnZ][y] !== undefined) {
                            groundY = y;
                            break;
                        }
                    }
                }
                
                // Check if this position is suitable (not on water and has solid ground)
                let isNearWater = false;
                let isOnWater = false;
                
                // Check if the spawn position itself is water
                if (getTerrainBlock(spawnX, spawnZ, groundY) === MATERIALS.WATER.id) {
                    isOnWater = true;
                }
                
                // Check for water in a larger area around the spawn position
                for (let dx = -3; dx <= 3; dx++) {
                    for (let dz = -3; dz <= 3; dz++) {
                        const checkX = spawnX + dx;
                        const checkZ = spawnZ + dz;
                        const wrappedCheckX = ((checkX % worldSize) + worldSize) % worldSize;
                        const wrappedCheckZ = ((checkZ % worldSize) + worldSize) % worldSize;
                        
                        // Check for water at ground level or one level above
                        if (getTerrainBlock(wrappedCheckX, wrappedCheckZ, groundY) === MATERIALS.WATER.id ||
                            getTerrainBlock(wrappedCheckX, wrappedCheckZ, groundY + 1) === MATERIALS.WATER.id) {
                            isNearWater = true;
                            break;
                        }
                    }
                    if (isNearWater) break;
                }
                
                // If not on water, not near water, and on solid ground, this is a good spawn
                if (!isOnWater && !isNearWater && terrain[spawnX] && terrain[spawnX][spawnZ] &&
                    terrain[spawnX][spawnZ][groundY] === MATERIALS.SOIL.id) {
                    foundSuitableSpawn = true;
                    playerPos.set(spawnX + 0.5, groundY + 2.0, spawnZ + 0.5); // +2.0 to stand on top of ground
                    console.log(`Found suitable spawn at (${spawnX}, ${groundY}, ${spawnZ})`);
                }
                
                attempts++;
            }
            
            // If we couldn't find a suitable spawn, try a more aggressive search
            if (!foundSuitableSpawn) {
                console.warn("Could not find suitable spawn location with first method, trying alternative");
                attempts = 0;
                
                // Try a grid search pattern
                for (let gridX = 10; gridX < worldSize - 10 && !foundSuitableSpawn; gridX += 10) {
                    for (let gridZ = 10; gridZ < worldSize - 10 && !foundSuitableSpawn; gridZ += 10) {
                        // Find the terrain height at this grid position
                        let groundY = 0;
                        if (terrain[gridX] && terrain[gridX][gridZ]) {
                            for (let y = worldSize - 1; y >= 0; y--) {
                                if (terrain[gridX][gridZ][y] !== undefined) {
                                    groundY = y;
                                    break;
                                }
                            }
                        }
                        
                        // Check if this position is suitable
                        if (getTerrainBlock(gridX, gridZ, groundY) !== MATERIALS.WATER.id &&
                            terrain[gridX] && terrain[gridX][gridZ] &&
                            terrain[gridX][gridZ][groundY] === MATERIALS.SOIL.id) {
                            
                            // Check for water in a 3x3 area
                            let isNearWater = false;
                            for (let dx = -2; dx <= 2; dx++) {
                                for (let dz = -2; dz <= 2; dz++) {
                                    const checkX = gridX + dx;
                                    const checkZ = gridZ + dz;
                                    const wrappedCheckX = ((checkX % worldSize) + worldSize) % worldSize;
                                    const wrappedCheckZ = ((checkZ % worldSize) + worldSize) % worldSize;
                                    
                                    if (getTerrainBlock(wrappedCheckX, wrappedCheckZ, groundY) === MATERIALS.WATER.id ||
                                        getTerrainBlock(wrappedCheckX, wrappedCheckZ, groundY + 1) === MATERIALS.WATER.id) {
                                        isNearWater = true;
                                        break;
                                    }
                                }
                                if (isNearWater) break;
                            }
                            
                            if (!isNearWater) {
                                foundSuitableSpawn = true;
                                playerPos.set(gridX + 0.5, groundY + 2.0, gridZ + 0.5);
                                console.log(`Found suitable spawn at grid position (${gridX}, ${groundY}, ${gridZ})`);
                            }
                        }
                    }
                }
            }
            
            // Last resort: use a default elevated position
            if (!foundSuitableSpawn) {
                console.error("Could not find any suitable spawn location, using default elevated position");
                playerPos.set(worldSize / 2, 8.0, worldSize / 2); // Higher default position
            }
            
            // Create a plane geometry instead of sprite to prevent transparency issues
            const geometry = new THREE.PlaneGeometry(1.8, 1.59);  // Normal size for non-fishing animations
            const spriteMaterial = new THREE.MeshBasicMaterial({
                map: playerAnimations.idleFront.texture,
                transparent: true,
                side: THREE.FrontSide,  // Use FrontSide to prevent overlap transparency
                color: 0xffffff,
                depthTest: true,
                depthWrite: false  // Don't write to depth buffer to prevent z-fighting
            });
            
            playerSprite = new THREE.Mesh(geometry, spriteMaterial);
            playerSprite.scale.set(1, 1, 1);
            playerSprite.position.copy(playerPos);
            
            // Store original scale to prevent shrinking during animations
            playerSprite.userData.originalScale = new THREE.Vector3(1, 1, 1);
            
            currentAnimation = playerAnimations.idleFront;
            currentAnimation.play();
            
            scene.add(playerSprite);
            player = playerSprite;
        }

        function updatePlayerAnimation(deltaTime) {
            if (isUsingTool && !toolAnimationComplete) {
                currentAnimation.update(deltaTime);
                
                if (currentAnimation.completed) {
                    if (keys['ShiftLeft'] || keys['ShiftRight'] || keys['Space']) { // if attack key is still down
                        currentAnimation.play(); // restart animation
                        
                        if (equippedTool && equippedTool.id === TOOLS.PICKAXE.id) {
                            destroyBlockInDirection();
                        } else if (equippedTool && equippedTool.id === TOOLS.AXE.id) {
                            cutTreeInDirection();
                        } else if (equippedTool && equippedTool.id === TOOLS.SWORD.id) {
                            attackInDirection();
                        }
                    } else {
                        isUsingTool = false;
                        toolAnimationComplete = true;
                        
                        // Return to idle animation after tool use
                        let animationSet;
                        if (equippedTool && equippedTool.id === TOOLS.PICKAXE.id) {
                            animationSet = playerAnimationsWithPickaxe;
                        } else if (equippedTool && equippedTool.id === TOOLS.AXE.id) {
                            animationSet = playerAnimationsWithAxe;
                        } else if (equippedTool && equippedTool.id === TOOLS.FISHING_ROD.id) {
                            animationSet = playerAnimationsWithFishingRod;
                        } else if (equippedTool && equippedTool.id === TOOLS.SWORD.id) {
                            animationSet = playerAnimationsWithSword;
                        } else {
                            animationSet = playerAnimations;
                        }
                        
                        currentAnimation = playerFacing === 'front' ?
                            animationSet.idleFront :
                            animationSet.idleBack;
                        currentAnimation.play();
                    }
                }
                
                updatePlayerSpriteTexture();
                return;
            }

            // Handle fishing animations
            if (isFishing && equippedTool && equippedTool.id === TOOLS.FISHING_ROD.id) {
                currentAnimation.update(deltaTime);
                
                // Check if current animation completed and handle state transitions
                if (currentAnimation.completed) {
                    if (fishingState === 'casting') {
                        fishingState = 'waiting';
                        currentAnimation = playerAnimationsWithFishingRod.waitingFront;
                        currentAnimation.play();
                    } else if (fishingState === 'catching') {
                        fishingState = 'idle';
                        currentAnimation = playerFacing === 'front' ?
                            playerAnimationsWithFishingRod.idleFront :
                            playerAnimationsWithFishingRod.idleBack;
                        currentAnimation.play();
                    }
                }
                
                updatePlayerSpriteTexture();
                return;
            }

            const isMoving = keys['ArrowUp'] || keys['ArrowDown'] ||
                            keys['ArrowLeft'] || keys['ArrowRight'] ||
                            keys['KeyW'] || keys['KeyS'] ||
                            keys['KeyA'] || keys['KeyD'];
            
            // Update facing and left/right flip based on movement (camera-relative)
            if (playerLastMoveDirection.lengthSq() > 0) {
                // Determine forward/back component relative to camera
                const cameraForward = new THREE.Vector3();
                cameraForward.subVectors(camera.position, playerPos).normalize();
                cameraForward.y = 0;

                const moveDirection = playerLastMoveDirection.clone().normalize();
                const dotForward = moveDirection.dot(cameraForward);

                // Default to front when movement is mostly lateral; threshold avoids jitter at 0
                const facingThreshold = 0.25;
                if (dotForward > facingThreshold) {
                    playerFacing = 'front';    // toward camera
                } else if (dotForward < -facingThreshold) {
                    playerFacing = 'back';     // away from camera
                } else {
                    playerFacing = 'front';    // pure left/right defaults to front
                }

                // Determine horizontal flip based on left/right relative to camera
                const cameraRight = new THREE.Vector3();
                cameraRight.crossVectors(cameraForward, new THREE.Vector3(0, 1, 0)).normalize();
                const dotRight = moveDirection.dot(cameraRight);
                
                // Simplified flipping logic: flip when moving right relative to camera
                // This works for both front and back facing, and handles diagonals correctly
                playerFlipX = dotRight > 0.1; // Add threshold to avoid jitter
                
                // Special case: when moving away from camera (back facing) and moving left, don't flip
                // This fixes the diagonal movement issue
                if (playerFacing === 'back' && dotRight < -0.1) {
                    playerFlipX = false;
                }
            }
            
            let animationSet;
            if (equippedTool && equippedTool.id === TOOLS.PICKAXE.id) {
                animationSet = playerAnimationsWithPickaxe;
            } else if (equippedTool && equippedTool.id === TOOLS.AXE.id) {
                animationSet = playerAnimationsWithAxe;
            } else if (equippedTool && equippedTool.id === TOOLS.FISHING_ROD.id) {
                animationSet = playerAnimationsWithFishingRod;
            } else if (equippedTool && equippedTool.id === TOOLS.SWORD.id) {
                animationSet = playerAnimationsWithSword;
            } else {
                animationSet = playerAnimations;
            }
            
            let newAnimation;
            if (isMoving) {
                newAnimation = playerFacing === 'front' ? animationSet.runFront : animationSet.runBack;
            } else {
                newAnimation = playerFacing === 'front' ? animationSet.idleFront : animationSet.idleBack;
            }
            
            if (newAnimation !== currentAnimation) {
                currentAnimation.stop();
                currentAnimation = newAnimation;
                currentAnimation.play();
            }
            
            currentAnimation.update(deltaTime);
            updatePlayerSpriteTexture();
            
            // Ensure player sprite maintains original scale during all animations
            if (playerSprite && !playerSprite.userData.isFishingScaled) {
                playerSprite.scale.set(1, 1, 1);
            }
            
            // Adjust geometry size for specific fishing animations to make them twice as big
            if (playerSprite && (currentAnimation === playerAnimationsWithFishingRod.castingFront ||
                                currentAnimation === playerAnimationsWithFishingRod.waitingFront ||
                                currentAnimation === playerAnimationsWithFishingRod.fishBiteFront ||
                                currentAnimation === playerAnimationsWithFishingRod.catchingFront)) {
                if (!playerSprite.userData.isFishingScaled) {
                    playerSprite.userData.isFishingScaled = true;
                    if (!playerSprite.userData.originalGeometry) {
                        playerSprite.userData.originalGeometry = playerSprite.geometry;
                    }
                    playerSprite.geometry = new THREE.PlaneGeometry(3.6, 3.18);
                }
            } else if (playerSprite && playerSprite.userData.isFishingScaled) {
                playerSprite.userData.isFishingScaled = false;
                if (playerSprite.userData.originalGeometry) {
                    playerSprite.geometry = playerSprite.userData.originalGeometry;
                }
            }
        }
        
        function updatePlayerSpriteTexture() {
            if (!currentAnimation || !playerSprite) return;
            
            // Get the current animation texture
            const texture = currentAnimation.texture;
            
            // Apply the current frame's texture coordinates
            texture.repeat.set(currentAnimation.frameWidth, currentAnimation.frameHeight);
            texture.offset.set(
                currentAnimation.currentFrame % currentAnimation.horizontalFrames * currentAnimation.frameWidth,
                1 - (Math.floor(currentAnimation.currentFrame / currentAnimation.horizontalFrames) + 1) * currentAnimation.frameHeight
            );
            
            playerSprite.material.map = texture;
            
            // Apply horizontal flip by adjusting the texture
            if (playerFlipX) {
                playerSprite.material.map.repeat.x = -currentAnimation.frameWidth;
                playerSprite.material.map.offset.x = 1 - (currentAnimation.currentFrame % currentAnimation.horizontalFrames * currentAnimation.frameWidth);
            } else {
                playerSprite.material.map.repeat.x = currentAnimation.frameWidth;
                playerSprite.material.map.offset.x = currentAnimation.currentFrame % currentAnimation.horizontalFrames * currentAnimation.frameWidth;
            }
            
            playerSprite.material.needsUpdate = true;
        }

        function getTerrainBlock(x, z, y) {
            // Wrap coordinates for infinite world
            const wrappedX = ((x % worldSize) + worldSize) % worldSize;
            const wrappedZ = ((z % worldSize) + worldSize) % worldSize;
            return terrain[wrappedX]?.[wrappedZ]?.[y];
        }

        // Physics
        let playerVelocityY = 0;
        const GRAVITY = 0.03;
        const JUMP_FORCE = 0.3;

        function jump() {
            // Check if on ground (or close enough)
            const x = Math.floor(playerPos.x);
            const z = Math.floor(playerPos.z);
            // Check deeper to find the block we are standing ON
            const feetY = Math.floor(playerPos.y - 1.5);
            
            // We can jump if standing on a block OR if we are at world bottom (2.0)
            const blockBeneath = getTerrainBlock(x, z, feetY);
            
            // Allow jump if velocity is near zero (standing)
            // AND (block beneath exists OR at ground level)
            // Relaxed velocity check slightly
            if (Math.abs(playerVelocityY) < 0.1 && (blockBeneath !== undefined || playerPos.y <= 2.1)) {
                playerVelocityY = JUMP_FORCE;
                // showNotification("Jump!");
            }
        }

        // New Animals
        let cats = [], chickens = [], cows = [], dragons = [];
        let catTexture, chickenTexture, cowTexture, dragonTexture;

        // ...

        function generateCats() {
            const num = 20; // Increased from 5
            console.log("Generating Cats...");
            let spawned = 0;
            for (let i = 0; i < num; i++) {
                const pos = findRandomSpawnPosition();
                if (!pos) continue;
                
                const geo = new THREE.PlaneGeometry(0.5, 0.5); // Small
                const mat = new THREE.MeshBasicMaterial({ map: catTexture, transparent: true, side: THREE.FrontSide, depthWrite: false });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                
                const group = createWrappedGroup(mesh, pos);
                scene.add(group);
                
                cats.push({ group, position: pos, type: 'cat', speed: 0.1, followDistance: 10, stopDistance: 1.5 });
                spawned++;
            }
            console.log(`Spawned ${spawned} cats`);
        }

        function generateChickens() {
            const num = 30; // Increased from 10
            console.log("Generating Chickens...");
            let spawned = 0;
            for (let i = 0; i < num; i++) {
                const pos = findRandomSpawnPosition();
                if (!pos) continue;
                
                const geo = new THREE.PlaneGeometry(0.4, 0.4); // Very small
                const mat = new THREE.MeshBasicMaterial({ map: chickenTexture, transparent: true, side: THREE.FrontSide, depthWrite: false });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                
                const group = createWrappedGroup(mesh, pos);
                scene.add(group);
                
                chickens.push({ group, position: pos, type: 'chicken', speed: 0.08, followDistance: 8, stopDistance: 1.0 });
                spawned++;
            }
            console.log(`Spawned ${spawned} chickens`);
        }

        function generateCows() {
            const num = 15; // Increased from 5
            console.log("Generating Cows...");
            let spawned = 0;
            for (let i = 0; i < num; i++) {
                const pos = findRandomSpawnPosition();
                if (!pos) continue;
                
                const geo = new THREE.PlaneGeometry(1.2, 1.0); // Normal/Large
                const mat = new THREE.MeshBasicMaterial({ map: cowTexture, transparent: true, side: THREE.FrontSide, depthWrite: false });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                
                const group = createWrappedGroup(mesh, pos);
                scene.add(group);
                
                cows.push({ group, position: pos, type: 'cow', speed: 0.06, followDistance: 12, stopDistance: 2.0 });
                spawned++;
            }
            console.log(`Spawned ${spawned} cows`);
        }

        function generateDragons() {
            const num = 5; // Increased from 2
            console.log("Generating Dragons...");
            let spawned = 0;
            for (let i = 0; i < num; i++) {
                const pos = findRandomSpawnPosition();
                if (!pos) continue;
                
                const geo = new THREE.PlaneGeometry(3.0, 3.0); // 3x bigger
                const mat = new THREE.MeshBasicMaterial({ map: dragonTexture, transparent: true, side: THREE.FrontSide, depthWrite: false });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                
                const group = createWrappedGroup(mesh, pos);
                scene.add(group);
                
                dragons.push({ group, position: pos, type: 'dragon', speed: 0.04, wander: true });
                spawned++;
            }
            console.log(`Spawned ${spawned} dragons`);
        }

        function findRandomSpawnPosition() {
            for(let i=0; i<50; i++) {
                const x = Math.floor(Math.random() * worldSize);
                const z = Math.floor(Math.random() * worldSize);
                // find ground
                if (!terrain[x] || !terrain[x][z]) continue;
                for (let y = worldSize - 1; y >= 0; y--) {
                    if (terrain[x][z][y] !== undefined && terrain[x][z][y] === MATERIALS.SOIL.id) {
                        return new THREE.Vector3(x + 0.5, y + 1.5, z + 0.5);
                    }
                }
            }
            return null;
        }

        function createWrappedGroup(mesh, pos) {
            const group = new THREE.Group();
            for (let offsetX = -1; offsetX <= 1; offsetX++) {
                for (let offsetZ = -1; offsetZ <= 1; offsetZ++) {
                    const copy = mesh.clone();
                    copy.position.set(pos.x + offsetX * worldSize, pos.y, pos.z + offsetZ * worldSize);
                    group.add(copy);
                }
            }
            return group;
        }

        function updateFollowAnimals(animals, deltaTime) {
            if (animals.length > 0 && Math.random() < 0.01) {
                 console.log(`Updating ${animals.length} animals of type ${animals[0].type}. First pos: ${JSON.stringify(animals[0].position)}`);
            }
            animals.forEach(animal => {
                const dist = getWrappedDistance(animal.position.x, animal.position.z, playerPos.x, playerPos.z);
                
                let moveDir = new THREE.Vector3(0,0,0);
                
                if (animal.wander) {
                    // Random wander logic (simplified)
                    if (Math.random() < 0.02) {
                        animal.wanderDir = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize();
                    }
                    if (animal.wanderDir) moveDir = animal.wanderDir;
                } else if (dist < animal.followDistance && dist > animal.stopDistance) {
                    // Follow player
                    moveDir = getWrappedDirection(animal.position.x, animal.position.z, playerPos.x, playerPos.z);
                } else if (Math.random() < 0.01) {
                     // Occasional idle wander
                     animal.wanderDir = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize();
                     moveDir = animal.wanderDir;
                }

                if (moveDir.lengthSq() > 0) {
                    animal.position.x += moveDir.x * animal.speed;
                    animal.position.z += moveDir.z * animal.speed;
                    
                    // Wrap
                    if (animal.position.x < 0) animal.position.x += worldSize;
                    if (animal.position.x >= worldSize) animal.position.x -= worldSize;
                    if (animal.position.z < 0) animal.position.z += worldSize;
                    if (animal.position.z >= worldSize) animal.position.z -= worldSize;
                    
                    // Height adjustment
                    const gx = Math.floor(animal.position.x);
                    const gz = Math.floor(animal.position.z);
                    let gy = 0;
                    // find top block
                    if (terrain[gx] && terrain[gx][gz]) {
                         for(let y=worldSize-1; y>=0; y--) {
                             if (terrain[gx][gz][y] !== undefined) {
                                 gy = y + 1;
                                 break;
                             }
                         }
                    }
                    animal.position.y = gy + (animal.type === 'dragon' ? 1.5 : 0.5); // Offset based on size
                }

                // Update group copies
                let idx = 0;
                animal.group.children.forEach(mesh => {
                    const ox = (idx % 3 - 1) * worldSize;
                    const oz = (Math.floor(idx / 3) - 1) * worldSize;
                    mesh.position.set(animal.position.x + ox, animal.position.y, animal.position.z + oz);
                    
                    // Billboard
                    const angle = Math.atan2(camera.position.x - mesh.position.x, camera.position.z - mesh.position.z);
                    mesh.rotation.y = angle;
                    
                    // Flip based on movement? (Simplified: just billboard)
                    idx++;
                });
            });
        }


        function updatePlayerPosition() {
            const x = Math.floor(playerPos.x);
            const z = Math.floor(playerPos.z);
            
            // Apply gravity
            playerVelocityY -= GRAVITY;
            // Terminal velocity
            playerVelocityY = Math.max(playerVelocityY, -0.5);
            
            playerPos.y += playerVelocityY;
            
            const feetY = Math.floor(playerPos.y - 1.0);
            
            // Check for ground collision
            if (playerVelocityY <= 0) {
                const blockBeneath = getTerrainBlock(x, z, feetY);
                if (blockBeneath !== undefined) {
                    // Landed on block
                    const groundTop = feetY + 1; // Top of the block
                    // Snap if we are close to the top (prevents falling through if moving fast)
                    // and we were above it before?
                    // Simple check: if feet are inside the block, snap up
                    if (playerPos.y - 1.0 < groundTop) {
                        playerPos.y = groundTop + 1.0;
                        playerVelocityY = 0;
                    }
                }
            }
            
            // Don't fall below world bottom
            if (playerPos.y < 2.0) {
                playerPos.y = 2.0;
                playerVelocityY = 0;
            }
            
            player.position.copy(playerPos);
        }

        function generateTerrain() {
            const heightMap = [];
            let blockCount = 0;

            const rawHeightMap = [];
            for (let x = 0; x < worldSize; x++) {
                rawHeightMap[x] = [];
                for (let z = 0; z < worldSize; z++) {
                    const height = Math.floor(noise(x, z) * 8) + 2; // Restored original height range with more variation
                    rawHeightMap[x][z] = height;
                }
            }

            for (let x = 0; x < worldSize; x++) {
                heightMap[x] = [];
                for (let z = 0; z < worldSize; z++) {
                    let totalHeight = 0;
                    let count = 0;

                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dz = -1; dz <= 1; dz++) {
                            // Wrap coordinates for seamless edges
                            const nx = (x + dx + worldSize) % worldSize;
                            const nz = (z + dz + worldSize) % worldSize;

                            totalHeight += rawHeightMap[nx][nz];
                            count++;
                        }
                    }

                    const smoothedHeight = Math.round(
                        rawHeightMap[x][z] * 0.6 + (totalHeight / count) * 0.4
                    );

                    heightMap[x][z] = Math.max(2, smoothedHeight); // Restored original minimum height
                }
            }

            for(let x = 0; x < worldSize; x++) {
                terrain[x] = [];
                blockMeshes[x] = [];
                for(let z = 0; z < worldSize; z++) {
                    terrain[x][z] = [];
                    blockMeshes[x][z] = [];
                }
            }

            for (let x = 0; x < worldSize; x++) {
                for (let z = 0; z < worldSize; z++) {
                    const maxHeight = heightMap[x][z];

                    for (let y = 0; y < maxHeight; y++) {
                        let materialType;

                        if (y < 2) {
                            materialType = Math.random() < 0.5 ? MATERIALS.ROCK : MATERIALS.METAL;
                        } else if (y < maxHeight - 2) {
                            const weightedRandom = Math.random();
                            if (weightedRandom < 0.5) materialType = MATERIALS.ROCK;
                            else materialType = MATERIALS.SOIL;
                        } else {
                            materialType = pickMaterialByFrequency();
                        }

                        if (y === maxHeight - 1) {
                            materialType = MATERIALS.SOIL;
                        }

                        terrain[x][z][y] = materialType.id;

                        const isVisible = isBlockVisibleInitial(x, y, z, heightMap);
                        if (isVisible) {
                            const blockMesh = createBlock(x, y, z, materialType);
                            blockMeshes[x][z][y] = blockMesh;
                        }
                        blockCount++;
                    }
                    
                    // Add surface water in low areas after terrain generation
                    const waterTableLevel = 3; // Lowered water level to reduce coverage
                    if (maxHeight <= waterTableLevel) {
                        // This is a low area, create surface water
                        const waterY = waterTableLevel; // Water surface at level 3
                        
                        // Only add water if there isn't already a block at this level
                        if (!terrain[x][z][waterY]) {
                            terrain[x][z][waterY] = MATERIALS.WATER.id;
                            
                            // Create water block mesh
                            const waterMesh = createBlock(x, waterY, z, MATERIALS.WATER);
                            blockMeshes[x][z][waterY] = waterMesh;
                        }
                    }
                }
            }
        }

        function noise(x, z) {
            // Make noise tileable by using periodic functions
            // Map coordinates to 0-2 range for seamless wrapping
            const tx = (x / worldSize) * 2 * Math.PI;
            const tz = (z / worldSize) * 2 * Math.PI;
            
            let value = 0;
            let amplitude = 1;
            let frequency = 1;
            let maxValue = 0;

            // Use combination of sin/cos for tileable noise
            let n1 = (Math.sin(tx * frequency) * Math.cos(tz * frequency) + 
                     Math.cos(tx * frequency) * Math.sin(tz * frequency)) * 0.5 + 0.5;
            value += n1 * amplitude;
            maxValue += amplitude;

            amplitude *= 0.6;
            frequency *= 2;

            let n2 = (Math.sin(tx * frequency + 1.5) * Math.cos(tz * frequency + 2.3) + 
                     Math.cos(tx * frequency) * Math.sin(tz * frequency)) * 0.5 + 0.5;
            value += n2 * amplitude;
            maxValue += amplitude;

            amplitude *= 0.5;
            frequency *= 2;

            let n3 = (Math.sin(tx * frequency + 3.7) * Math.cos(tz * frequency + 4.1) + 
                     Math.cos(tx * frequency + 0.5) * Math.sin(tz * frequency + 1.2)) * 0.5 + 0.5;
            value += n3 * amplitude;
            maxValue += amplitude;

            return value / maxValue;
        }

        function pickMaterialByFrequency() {
            let totalFrequency = 0;
            for (const key in MATERIALS) {
                totalFrequency += MATERIALS[key].frequency;
            }

            let random = Math.random() * totalFrequency;
            for (const key in MATERIALS) {
                random -= MATERIALS[key].frequency;
                if (random <= 0) {
                    return MATERIALS[key];
                }
            }
            return MATERIALS.SOIL;
        }

        function isBlockVisibleInitial(x, y, z, heightMap) {
            const currentHeight = heightMap[x][z];
            if (y === currentHeight - 1) return true;

            const neighbors = [
                { nx: x - 1, nz: z },
                { nx: x + 1, nz: z },
                { nx: x, nz: z - 1 },
                { nx: x, nz: z + 1 }
            ];

            for (const neighbor of neighbors) {
                const { nx, nz } = neighbor;
                if (nx < 0 || nx >= worldSize || nz < 0 || nz >= worldSize) {
                    return true;
                }
                const neighborHeight = heightMap[nx][nz];
                if (neighborHeight <= y) {
                    return true;
                }
            }
            return false;
        }

        function isBlockVisibleRuntime(x, y, z) {
            if (x < 0 || x >= worldSize || y < 0 || y >= worldSize || z < 0 || z >= worldSize) {
                return false;
            }

            const isAir = (terrain[x]?.[z]?.[y] === undefined);
            if (isAir) return false;

            const hasBlockAbove = (y + 1 < worldSize && terrain[x]?.[z]?.[y + 1] !== undefined);
            if (!hasBlockAbove) return true;

            const checkNeighbors = [
                { dx: 1, dy: 0, dz: 0 }, { dx: -1, dy: 0, dz: 0 },
                { dx: 0, dy: 0, dz: 1 }, { dx: 0, dy: 0, dz: -1 }
            ];

            for (const dir of checkNeighbors) {
                const nx = x + dir.dx;
                const ny = y + dir.dy;
                const nz = z + dir.dz;

                if (nx < 0 || nx >= worldSize || nz < 0 || nz >= worldSize ||
                    terrain[nx]?.[nz]?.[ny] === undefined) {
                    return true;
                }
            }
            return false;
        }

        function createBlock(x, y, z, materialType) {
            const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
            let blockMaterial;

            if (materialType.id === MATERIALS.SOIL.id) {
                // Cache and reuse soil materials for better performance
                if (!cachedSoilMaterials) {
                    cachedSoilMaterials = [
                        new THREE.MeshLambertMaterial({ map: soilTexture }), // right
                        new THREE.MeshLambertMaterial({ map: soilTexture }), // left
                        new THREE.MeshLambertMaterial({ map: grassTexture }), // top (grass)
                        new THREE.MeshLambertMaterial({ map: soilTexture }), // bottom
                        new THREE.MeshLambertMaterial({ map: soilTexture }), // front
                        new THREE.MeshLambertMaterial({ map: soilTexture })  // back
                    ];
                }
                blockMaterial = cachedSoilMaterials;
            } else if (materialType.id === MATERIALS.ROCK.id) {
                if (!cachedRockMaterial) {
                    cachedRockMaterial = new THREE.MeshLambertMaterial({ map: rockTexture });
                }
                blockMaterial = cachedRockMaterial;
            } else if (materialType.id === MATERIALS.METAL.id) {
                if (!cachedMetalMaterial) {
                    cachedMetalMaterial = new THREE.MeshLambertMaterial({ map: metalTexture });
                }
                blockMaterial = cachedMetalMaterial;
            } else if (materialType.id === MATERIALS.WOOD.id) {
                if (!cachedWoodMaterial) {
                    cachedWoodMaterial = new THREE.MeshLambertMaterial({ map: woodTexture });
                }
                blockMaterial = cachedWoodMaterial;
            } else if (materialType.id === MATERIALS.WATER.id) {
                if (!cachedWaterMaterial) {
                    cachedWaterMaterial = new THREE.MeshLambertMaterial({
                        map: waterTexture,
                        transparent: true,
                        opacity: 0.8
                    });
                }
                blockMaterial = cachedWaterMaterial;
            } else {
                blockMaterial = new THREE.MeshLambertMaterial({ color: materialType.color });
            }

            // Create a group to hold 9 copies of the block (3x3 grid for seamless wrapping)
            const blockGroup = new THREE.Group();
            
            // Create 9 instances of the block at different offsets
            for (let offsetX = -1; offsetX <= 1; offsetX++) {
                for (let offsetZ = -1; offsetZ <= 1; offsetZ++) {
                    const block = new THREE.Mesh(geometry, blockMaterial);
                    block.position.set(
                        x + offsetX * worldSize, 
                        y, 
                        z + offsetZ * worldSize
                    );
                    blockGroup.add(block);
                }
            }
            
            scene.add(blockGroup);
            return blockGroup;
        }

        let ownedTools = new Set([TOOLS.PICKAXE.id]);

        function isNearCampfire() {
             const x = Math.floor(playerPos.x);
             const y = Math.floor(playerPos.y);
             const z = Math.floor(playerPos.z);
             
             // Check radius 2
             return campfires.some(f => {
                 return Math.abs(f.x - x) < 3 && Math.abs(f.z - z) < 3 && Math.abs(f.y - (y-1)) < 3;
             });
        }

        function checkCrafting() {
             // Check if Metal is selected
             const metalId = MATERIALS.METAL.id;
             if (!selectedMaterials.has(metalId)) return false;
             
             if (!isNearCampfire()) {
                 return false;
             }
             
             showCraftingMenu();
             return true;
        }

        function showCraftingMenu() {
            // Create a simple HTML overlay
            let menu = document.getElementById('craftingMenu');
            if (!menu) {
                menu = document.createElement('div');
                menu.id = 'craftingMenu';
                menu.style.cssText = `
                    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                    background: rgba(0,0,0,0.9); padding: 20px; border: 2px solid #FF9800;
                    color: white; z-index: 100; text-align: center; border-radius: 10px;
                    min-width: 250px;
                `;
                document.body.appendChild(menu);
            }
            
            menu.innerHTML = '<h3>Manufacturing</h3>';
            
            const tools = [
                { name: 'Axe', cost: 1, id: TOOLS.AXE.id },
                { name: 'Pickaxe', cost: 1, id: TOOLS.PICKAXE.id },
                { name: 'Sword', cost: 2, id: TOOLS.SWORD.id }
            ];
            
            tools.forEach(tool => {
                if (ownedTools.has(tool.id)) return; // Already owned
                
                const btn = document.createElement('button');
                btn.textContent = `Craft ${tool.name} (${tool.cost} Metal)`;
                btn.className = 'action-button';
                btn.style.display = 'block';
                btn.style.margin = '10px auto';
                btn.style.width = '100%';
                
                btn.onclick = () => {
                    craftTool(tool);
                    menu.style.display = 'none';
                };
                
                menu.appendChild(btn);
            });
            
            if (menu.children.length === 1) { // Only header
                 menu.innerHTML += '<p>You own all tools!</p>';
            }
            
            const closeBtn = document.createElement('button');
            closeBtn.textContent = "Cancel";
            closeBtn.className = 'action-button';
            closeBtn.style.backgroundColor = '#666';
            closeBtn.onclick = () => menu.style.display = 'none';
            menu.appendChild(closeBtn);
            
            menu.style.display = 'block';
        }
        
        function craftTool(tool) {
            if ((inventory['Metal'] || 0) < tool.cost) {
                showNotification("Not enough metal!");
                return;
            }
            
            const onComplete = () => {
                 inventory['Metal'] -= tool.cost;
                 ownedTools.add(tool.id);
                 updateInventoryUI();
                 showNotification(`Crafted ${tool.name}!`);
            };
            
            startLongAction('manufacturing', onComplete, null, 30000);
        }

        function updateInventoryUI() {
            const inventoryDiv = document.getElementById('materialInventory');
            inventoryDiv.innerHTML = '';
            
            // Add materials to inventory
            for (const materialKey in MATERIALS) {
                const materialType = MATERIALS[materialKey];
                const count = inventory[materialType.name] || 0;

                const p = document.createElement('p');
                p.textContent = `${materialType.name}: ${count}`;
                p.dataset.materialId = materialType.id;

                if (selectedMaterials.has(materialType.id)) {
                    p.classList.add('selected');
                }

                p.addEventListener('click', () => {
                    if (selectedMaterials.has(materialType.id)) {
                        selectedMaterials.delete(materialType.id);
                    } else {
                        selectedMaterials.add(materialType.id);
                    }
                    plantingSeeds = false;
                    plantingBushSeeds = false;
                    updateInventoryUI();
                });

                inventoryDiv.appendChild(p);
            }

            // Resource inventory
            const resourceDiv = document.getElementById('resourceInventory');
            resourceDiv.innerHTML = '';
            
            const hasResources = inventory['Wood'] || inventory['Seeds'] || inventory['Bush Seeds'] || inventory['Fruit'] || inventory['Medicinal Herb'] || inventory['Fish'] || inventory['Flax'];
            
            if (hasResources) {
                if (inventory['Wood']) {
                    const woodItem = document.createElement('p');
                    woodItem.textContent = `Wood: ${inventory['Wood']}`;
                    
                    // Add "Make Fire" button if we have wood
                    const fireBtn = document.createElement('button');
                    fireBtn.textContent = "Make Fire";
                    fireBtn.className = "action-button";
                    fireBtn.style.fontSize = "10px";
                    fireBtn.style.padding = "2px 5px";
                    fireBtn.style.marginLeft = "10px";
                    fireBtn.onclick = (e) => {
                        e.stopPropagation();
                        createCampfire();
                    };
                    woodItem.appendChild(fireBtn);
                    
                    resourceDiv.appendChild(woodItem);
                }

                if (inventory['Flax']) {
                    const flaxItem = document.createElement('p');
                    flaxItem.textContent = `Flax: ${inventory['Flax']}`;
                    resourceDiv.appendChild(flaxItem);
                }

                if (inventory['Seeds']) {
                    const seedsItem = document.createElement('p');
                    seedsItem.textContent = `Tree Seeds: ${inventory['Seeds']}`;
                    seedsItem.dataset.resource = 'Seeds';
                    seedsItem.style.cursor = 'pointer';
                    seedsItem.style.padding = '8px 12px';
                    seedsItem.style.margin = '5px 0';
                    seedsItem.style.borderRadius = '5px';
                    seedsItem.style.transition = 'all 0.2s';
                    
                    if (plantingSeeds) {
                        seedsItem.classList.add('selected');
                    }
                    
                    seedsItem.addEventListener('click', () => {
                        if ((inventory['Seeds'] || 0) > 0) {
                            plantingSeeds = !plantingSeeds;
                            plantingBushSeeds = false;
                            selectedMaterials.clear();
                            updateInventoryUI();
                        }
                    });
                    
                    resourceDiv.appendChild(seedsItem);
                }
                
                if (inventory['Bush Seeds']) {
                    const bushSeedsItem = document.createElement('p');
                    bushSeedsItem.textContent = `Bush Seeds: ${inventory['Bush Seeds']}`;
                    bushSeedsItem.dataset.resource = 'BushSeeds';
                    bushSeedsItem.style.cursor = 'pointer';
                    bushSeedsItem.style.padding = '8px 12px';
                    bushSeedsItem.style.margin = '5px 0';
                    bushSeedsItem.style.borderRadius = '5px';
                    bushSeedsItem.style.transition = 'all 0.2s';
                    
                    if (plantingBushSeeds) {
                        bushSeedsItem.classList.add('selected');
                    }
                    
                    bushSeedsItem.addEventListener('click', () => {
                        if ((inventory['Bush Seeds'] || 0) > 0) {
                            plantingBushSeeds = !plantingBushSeeds;
                            plantingSeeds = false;
                            selectedMaterials.clear();
                            updateInventoryUI();
                        }
                    });
                    
                    resourceDiv.appendChild(bushSeedsItem);
                }
                
                if (inventory['Fruit']) {
                    const fruitItem = document.createElement('p');
                    fruitItem.textContent = `Fruit: ${inventory['Fruit']} (F to eat)`;
                    fruitItem.style.cursor = 'pointer';
                    fruitItem.style.padding = '8px 12px';
                    fruitItem.style.margin = '5px 0';
                    fruitItem.style.borderRadius = '5px';
                    fruitItem.style.background = 'rgba(255, 255, 255, 0.1)';
                    fruitItem.style.transition = 'all 0.2s';
                    
                    fruitItem.addEventListener('mouseenter', () => {
                        fruitItem.style.background = 'rgba(76, 175, 80, 0.3)';
                    });
                    
                    fruitItem.addEventListener('mouseleave', () => {
                        fruitItem.style.background = 'rgba(255, 255, 255, 0.1)';
                    });
                    
                    fruitItem.addEventListener('click', () => {
                        consumeFruit();
                    });
                    resourceDiv.appendChild(fruitItem);
                }
                
                if (inventory['Medicinal Herb']) {
                    const herbItem = document.createElement('p');
                    herbItem.textContent = `Medicinal Herb: ${inventory['Medicinal Herb']} (H to use)`;
                    herbItem.style.cursor = 'pointer';
                    herbItem.style.padding = '8px 12px';
                    herbItem.style.margin = '5px 0';
                    herbItem.style.borderRadius = '5px';
                    herbItem.style.background = 'rgba(255, 255, 255, 0.1)';
                    herbItem.style.transition = 'all 0.2s';
                    
                    herbItem.addEventListener('mouseenter', () => {
                        herbItem.style.background = 'rgba(76, 175, 80, 0.3)';
                    });
                    
                    herbItem.addEventListener('mouseleave', () => {
                        herbItem.style.background = 'rgba(255, 255, 255, 0.1)';
                    });
                    
                    herbItem.addEventListener('click', () => {
                        useHerb();
                    });
                    resourceDiv.appendChild(herbItem);
                }
                
                if (inventory['Fish']) {
                    const fishItem = document.createElement('p');
                    fishItem.textContent = `Fish: ${inventory['Fish']} (Click to eat)`;
                    fishItem.style.cursor = 'pointer';
                    fishItem.style.padding = '8px 12px';
                    fishItem.style.margin = '5px 0';
                    fishItem.style.borderRadius = '5px';
                    fishItem.style.background = 'rgba(255, 255, 255, 0.1)';
                    fishItem.style.transition = 'all 0.2s';
                    
                    fishItem.addEventListener('mouseenter', () => {
                        fishItem.style.background = 'rgba(76, 175, 80, 0.3)';
                    });
                    
                    fishItem.addEventListener('mouseleave', () => {
                        fishItem.style.background = 'rgba(255, 255, 255, 0.1)';
                    });
                    
                    fishItem.addEventListener('click', () => {
                        eatFish();
                    });
                    resourceDiv.appendChild(fishItem);
                }
            } else {
                resourceDiv.innerHTML = '<p>No resources</p>';
            }

            // Tool inventory
            const toolDiv = document.getElementById('toolInventory');
            toolDiv.innerHTML = '';
            
            const createToolItem = (tool, name) => {
                if (!ownedTools.has(tool.id)) return null;

                const item = document.createElement('p');
                item.textContent = name;
                item.dataset.toolId = tool.id;
                
                if (equippedTool && equippedTool.id === tool.id) {
                    item.classList.add('selected');
                }

                item.addEventListener('click', () => {
                    if (equippedTool && equippedTool.id === tool.id) {
                        equippedTool = null;
                        if (tool.id === TOOLS.FISHING_ROD.id) stopFishing();
                    } else {
                        equippedTool = tool;
                        // Do not clear selected materials
                        plantingSeeds = false;
                    }
                    updateInventoryUI();
                });
                return item;
            };

            const pickaxe = createToolItem(TOOLS.PICKAXE, 'Pickaxe');
            if(pickaxe) toolDiv.appendChild(pickaxe);
            
            const axe = createToolItem(TOOLS.AXE, 'Axe');
            if(axe) toolDiv.appendChild(axe);
            
            const rod = createToolItem(TOOLS.FISHING_ROD, 'Fishing Rod');
            if(rod) toolDiv.appendChild(rod);
            
            const sword = createToolItem(TOOLS.SWORD, 'Sword');
            if(sword) toolDiv.appendChild(sword);

            // Plant button state
            const plantButton = document.getElementById('plantButton');
            const hasSeeds = (inventory['Seeds'] || 0) > 0;
            const hasBushSeeds = (inventory['Bush Seeds'] || 0) > 0;
            
            if (hasSeeds && hasBushSeeds) {
                plantButton.textContent = 'Plant Tree/Bush (Select Seeds)';
                plantButton.style.display = 'block';
            } else if (hasSeeds) {
                plantButton.textContent = 'Plant Tree (Seeds)';
                plantButton.style.display = 'block';
            } else if (hasBushSeeds) {
                plantButton.textContent = 'Plant Bush (Bush Seeds)';
                plantButton.style.display = 'block';
            } else {
                plantButton.style.display = 'none';
            }
        }

        function updateSkillsUI() {
            const skillsList = document.getElementById('skillsList');
            skillsList.innerHTML = '';
            for (const skill in skills) {
                const p = document.createElement('p');
                p.textContent = `${skill.charAt(0).toUpperCase() + skill.slice(1)}: ${skills[skill]}`;
                skillsList.appendChild(p);
            }
        }

        function attackInDirection() {
            if (playerLastMoveDirection.lengthSq() === 0) {
                return false; // No direction
            }

            const playerX = Math.round(playerPos.x);
            const playerZ = Math.round(playerPos.z);
            const dirX = Math.round(playerLastMoveDirection.x);
            const dirZ = Math.round(playerLastMoveDirection.z);
            const targetX = playerX + dirX;
            const targetZ = playerZ + dirZ;

            // Check for bear
            const bearIndex = bears.findIndex(bear => {
                if (bear.isDying) return false;
                const bearX = Math.floor(bear.position.x);
                const bearZ = Math.floor(bear.position.z);
                return bearX === targetX && bearZ === targetZ;
            });

            if (bearIndex !== -1) {
                const bear = bears[bearIndex];
                bear.health -= (PLAYER_ATTACK_DAMAGE + skills.fighting);
                bear.healthBar.scale.x = bear.health / BEAR_MAX_HEALTH;
                if (bear.health <= 0) {
                    bear.isDying = true;
                    showNotification("Killed bear!");
                    levelUpSkill('fighting', 2);
                } else {
                    showNotification(`Hit bear! ${bear.health} HP remaining`);
                }
                return true; // Attack happened
            }

            // Check for wolf
            const wolfIndex = wolves.findIndex(wolf => {
                if (wolf.isDying) return false;
                const wolfX = Math.floor(wolf.position.x);
                const wolfZ = Math.floor(wolf.position.z);
                return wolfX === targetX && wolfZ === targetZ;
            });

            if (wolfIndex !== -1) {
                const wolf = wolves[wolfIndex];
                wolf.health -= (PLAYER_ATTACK_DAMAGE + skills.fighting);
                wolf.healthBar.scale.x = wolf.health / WOLF_MAX_HEALTH;
                if (wolf.health <= 0) {
                    wolf.isDying = true;
                    showNotification("Killed wolf!");
                    levelUpSkill('fighting', 1);
                } else {
                    showNotification(`Hit wolf! ${wolf.health} HP remaining`);
                }
                return true; // Attack happened
            }

            return false; // No attack
        }

        function attackAnimalInDirection() {
            const attackDistance = 1.5;
            const direction = playerLastMoveDirection.clone().normalize();
            const attackPos = playerPos.clone().add(direction.multiplyScalar(attackDistance));

            // Check for bears
            for (const bear of bears) {
                if (bear.isDying) continue;
                const distance = getWrappedDistance(attackPos.x, attackPos.z, bear.position.x, bear.position.z);
                if (distance < 1.5) {
                    bear.health -= (PLAYER_ATTACK_DAMAGE + skills.fighting);
                    showNotification(`Attacked bear! Health: ${bear.health.toFixed(0)}/${BEAR_MAX_HEALTH}`, 1000);
                    
                    // Update health bar
                    const healthPercentage = bear.health / BEAR_MAX_HEALTH;
                    const healthBarScale = Math.max(0, healthPercentage);
                    bear.healthBar.scale.x = healthBarScale;
                    bear.healthBar.material.color.set(healthPercentage > 0.5 ? 0x00ff00 : (healthPercentage > 0.25 ? 0xffff00 : 0xff0000));
                    
                    if (bear.health <= 0 && !bear.isDying) {
                        bear.isDying = true;
                        levelUpSkill('fighting');
                        inventory['Leather'] = (inventory['Leather'] || 0) + 5;
                        inventory['Meat'] = (inventory['Meat'] || 0) + 3;
                        updateInventoryUI();
                        showNotification("Bear defeated! +5 Leather, +3 Meat", 2000);
                    }
                    return; // Only attack one animal at a time
                }
            }

            // Check for wolves
            for (const wolf of wolves) {
                if (wolf.isDying) continue;
                const distance = getWrappedDistance(attackPos.x, attackPos.z, wolf.position.x, wolf.position.z);
                if (distance < 1.5) {
                    wolf.health -= (PLAYER_ATTACK_DAMAGE + skills.fighting);
                    showNotification(`Attacked wolf! Health: ${wolf.health.toFixed(0)}/${WOLF_MAX_HEALTH}`, 1000);

                    // Update health bar
                    const healthPercentage = wolf.health / WOLF_MAX_HEALTH;
                    const healthBarScale = Math.max(0, healthPercentage);
                    wolf.healthBar.scale.x = healthBarScale;
                    wolf.healthBar.material.color.set(healthPercentage > 0.5 ? 0x00ff00 : (healthPercentage > 0.25 ? 0xffff00 : 0xff0000));

                    if (wolf.health <= 0 && !wolf.isDying) {
                        wolf.isDying = true;
                        levelUpSkill('fighting', 0.5); // Less skill for wolves
                        inventory['Fur'] = (inventory['Fur'] || 0) + 2;
                        inventory['Meat'] = (inventory['Meat'] || 0) + 1;
                        updateInventoryUI();
                        showNotification("Wolf defeated! +2 Fur, +1 Meat", 2000);
                    }
                    return; // Only attack one animal at a time
                }
            }
        }

        function destroyBlockInDirection() {
            if (!equippedTool || equippedTool.id !== TOOLS.PICKAXE.id) {
                showNotification("Equip pickaxe first!");
                return;
            }
            if (isPerformingLongAction) {
                showNotification("Already performing an action.");
                return;
            }
            if (attackInDirection()) {
                return; // An attack was initiated
            }
            if (playerLastMoveDirection.lengthSq() === 0) {
                showNotification("Move first to target a block");
                return;
            }

            const playerX = Math.round(playerPos.x);
            const playerFeetY = Math.floor(playerPos.y - 1.0);
            const playerZ = Math.round(playerPos.z);

            const dirX = Math.round(playerLastMoveDirection.x);
            const dirZ = Math.round(playerLastMoveDirection.z);
            
            const targetX = playerX + dirX;
            const targetZ = playerZ + dirZ;

            let targetBlockCoords = null;

            let checkX = playerX + dirX;
            let checkZ = playerZ + dirZ;
            
            // Check blocks at different heights
            if (getBlockMeshAt(checkX, playerFeetY, checkZ)) {
                targetBlockCoords = { x: checkX, y: playerFeetY, z: checkZ };
            } else if (getBlockMeshAt(checkX, playerFeetY + 1, checkZ)) {
                targetBlockCoords = { x: checkX, y: playerFeetY + 1, z: checkZ };
            } else if (getBlockMeshAt(checkX, playerFeetY - 1, checkZ)) {
                targetBlockCoords = { x: checkX, y: playerFeetY - 1, z: checkZ };
            } else if (getBlockMeshAt(checkX, playerFeetY + 2, checkZ)) {
                targetBlockCoords = { x: checkX, y: playerFeetY + 2, z: checkZ };
            }

            if (targetBlockCoords) {
                const { x, y, z } = targetBlockCoords;
                
                const onComplete = () => {
                    const blockToDestroyMesh = blockMeshes[x][z][y];
                    if (!blockToDestroyMesh) return; // Block already gone

                    const materialId = terrain[x][z][y];
                    let destroyedMaterialName = 'Unknown';
                    for (const key in MATERIALS) {
                        if (MATERIALS[key].id === materialId) {
                            destroyedMaterialName = MATERIALS[key].name;
                            break;
                        }
                    }

                    inventory[destroyedMaterialName] = (inventory[destroyedMaterialName] || 0) + 1;
                    updateInventoryUI();
                    saveGameState();

                    scene.remove(blockToDestroyMesh);
                    // Dispose geometry from all 9 copies
                    for (const blockCopy of blockToDestroyMesh.children) {
                        blockCopy.geometry.dispose();
                    }
                    // Don't dispose materials - they are cached and reused

                    blockMeshes[x][z][y] = undefined;
                    terrain[x][z][y] = undefined;

                    showNotification(`Destroyed ${destroyedMaterialName} block`);
                    updateSurroundingBlockVisibility(x, y, z);
                    
                    // Check if any trees are standing on this block and remove them
                    checkTreesAboveBlock(x, y, z);
                };
                
                startLongAction('mining', onComplete, { x, y, z });

            } else {
                showNotification("No block to destroy");
            }
        }

        function cutTreeInDirection() {
            if (!equippedTool || (equippedTool.id !== TOOLS.AXE.id && equippedTool.id !== TOOLS.PICKAXE.id)) {
                showNotification("Equip axe or pickaxe first!");
                return;
            }
            if (isPerformingLongAction) {
                showNotification("Already performing an action.");
                return;
            }
            if (attackInDirection()) {
                return; // An attack was initiated
            }
            if (playerLastMoveDirection.lengthSq() === 0) {
                showNotification("Move first to target a tree");
                return;
            }

            const playerX = Math.round(playerPos.x);
            const playerZ = Math.round(playerPos.z);

            const dirX = Math.round(playerLastMoveDirection.x);
            const dirZ = Math.round(playerLastMoveDirection.z);

            const targetX = playerX + dirX;
            const targetZ = playerZ + dirZ;
            
            // Check for bush
            const bushIndex = bushes.findIndex(bush => 
                Math.round(bush.x) === targetX && 
                Math.round(bush.z) === targetZ
            );

            if (bushIndex !== -1) {
                const bush = bushes[bushIndex];
                
                // If flax
                if (bush.type === FLAX_BUSH_INDEX) {
                    inventory['Flax'] = (inventory['Flax'] || 0) + (1 + Math.floor(Math.random() * 2));
                    showNotification("Harvested Flax!");
                } else {
                    // Add bush seeds to inventory
                    inventory['Bush Seeds'] = (inventory['Bush Seeds'] || 0) + (1 + Math.floor(Math.random() * 2)); // 1-2 seeds
                    showNotification("Cut down bush! Got seeds");
                }
                
                scene.remove(bush.group);
                bushes.splice(bushIndex, 1);
                updateInventoryUI();
                return;
            }

            // Find tree at target position
            const treeIndex = trees.findIndex(tree => 
                Math.round(tree.x) === targetX && 
                Math.round(tree.z) === targetZ &&
                !tree.isFalling
            );

            if (treeIndex !== -1) {
                const onComplete = () => {
                    const tree = trees[treeIndex];
                    if (!tree || tree.isFalling) return;

                    const treeType = TREE_TYPES[tree.type];
                    
                    // Add wood and seeds to inventory
                    inventory['Wood'] = (inventory['Wood'] || 0) + tree.wood;
                    inventory['Seeds'] = (inventory['Seeds'] || 0) + tree.seeds;
                    
                    // Set tree to falling state
                    tree.isFalling = true;
                    tree.fallProgress = 0;
                    
                    // Determine fall direction based on player position
                    const dx = playerPos.x - tree.x;
                    tree.fallDirection = dx < 0 ? -1 : 1; // Left or right
                    
                    // Set rotation axis
                    tree.rotationAxis = new THREE.Vector3(0, 0, 1);
                    
                    showNotification(`Cut down ${treeType.name} tree`);
                    updateInventoryUI();
                };

                // Calculate duration based on tool
                let baseDuration = 30000; // Axe default
                if (equippedTool.id === TOOLS.PICKAXE.id) {
                    baseDuration = 60000; // Pickaxe is 2x slower
                }

                startLongAction('lumberjacking', onComplete, null, baseDuration);

            } else {
                showNotification("No tree to cut");
            }
        }

        function pickFruitInDirection() {
            if (equippedTool) {
                showNotification("Unequip tool first!");
                return;
            }
            if (playerLastMoveDirection.lengthSq() === 0) {
                showNotification("Move first to target a tree");
                return;
            }

            const playerX = Math.round(playerPos.x);
            const playerZ = Math.round(playerPos.z);

            const dirX = Math.round(playerLastMoveDirection.x);
            const dirZ = Math.round(playerLastMoveDirection.z);

            const targetX = playerX + dirX;
            const targetZ = playerZ + dirZ;

            // Find tree at target position
            const treeIndex = trees.findIndex(tree => 
                Math.round(tree.x) === targetX && 
                Math.round(tree.z) === targetZ &&
                !tree.isFalling &&
                tree.isFruitTree &&
                !tree.fruitPicked
            );

            if (treeIndex !== -1) {
                const tree = trees[treeIndex];
                
                // Switch to non-fruit texture for all 9 copies
                for (const treeCopy of tree.group.children) {
                    updateTreeTexture(treeCopy.children[0], tree.type, false);
                }
                
                // Add fruit to inventory
                inventory['Fruit'] = (inventory['Fruit'] || 0) + tree.fruit;
                
                // Mark fruit as picked
                tree.fruitPicked = true;
                tree.fruitPickTime = Date.now();
                
                showNotification(`Picked ${tree.fruit} Fruit`);
                updateInventoryUI();
            }
            // Don't show "no fruit" notification - let herb harvesting try instead
        }

        function updateFallingTrees(deltaTime) {
    for (let i = trees.length - 1; i >= 0; i--) {
        const tree = trees[i];
        
        // Simple distance-based culling with wrapping
        const distanceToPlayer = getWrappedDistance(
            tree.x, tree.z,
            playerPos.x, playerPos.z
        );
        
        // Only update trees within 10 blocks of player (reduced for closer fog)
        if (distanceToPlayer > 10 && !tree.isFalling) {
            tree.group.visible = false;
            continue;
        } else {
            tree.group.visible = true;
        }

        if (!tree.isFalling) {
            // Make trees billboard to a point 100m behind the camera
            for (const treeCopy of tree.group.children) {
                const angle = Math.atan2(
                    billboardTargetPoint.x - treeCopy.position.x,
                    billboardTargetPoint.z - treeCopy.position.z
                );
                treeCopy.rotation.y = angle;
            }
            continue;
        }

        tree.fallProgress = Math.min(tree.fallProgress + deltaTime * 1.2, 1);

        // rotate the **group** around its local Z-axis (base stays put)
        tree.group.rotation.z = tree.fallDirection * (Math.PI / 2) * tree.fallProgress;

        // fade and remove
        if (tree.fallProgress >= 1) {
            tree.mesh.material.opacity -= deltaTime * 2;
            if (tree.mesh.material.opacity <= 0) {
                scene.remove(tree.group);
                trees.splice(i, 1);
            }
        }
    }
}

// Generate a subtle random tint emphasizing red, blue, or yellow
function randomTreeTint() {
    const amt = 0.15 + Math.random() * 0.2; // 0.15 - 0.35 emphasis
    // 0 = red, 1 = blue, 2 = yellow
    const variant = Math.floor(Math.random() * 3);
    let r = 1, g = 1, b = 1;
    if (variant === 0) {        // red: reduce G and B
        g = 1 - amt;
        b = 1 - amt;
    } else if (variant === 1) { // blue: reduce R and G
        r = 1 - amt;
        g = 1 - amt;
    } else {                    // yellow: reduce B (R+G high)
        b = 1 - amt;
    }
    const color = new THREE.Color(r, g, b);
    // slight random overall shade (darken up to ~10% for better visibility)
    const shade = 0.9 + Math.random() * 0.1; // 0.9 - 1.0 (less darkening)
    color.multiplyScalar(shade);
    return color;
}

function updateTreeTexture(treeMesh, treeType, hasFruit) {
    // Choose the appropriate texture
    const sourceTexture = hasFruit ? globalTreeWithFruitTexture : globalTreeTexture;
    
    // Clone the texture for this specific tree
    const tex = sourceTexture.clone();
    tex.needsUpdate = true;
    
    // Set the atlas rectangle for this tree type
    const cols = 4, rows = 2;
    const fw = 1 / cols, fh = 1 / rows;
    const col = treeType % cols;
    const row = Math.floor(treeType / rows);
    tex.repeat.set(fw, fh);
    tex.offset.set(col * fw, 1 - (row + 1) * fh);
    
    // Update the mesh material's texture
    treeMesh.material.map = tex;
    treeMesh.material.needsUpdate = true;
}

function createTreeMesh(typeId) {
    const treeData = TREE_TYPES[typeId];

    // 1. clone the texture so each tree has its own UV rectangle
    const tex = globalTreeTexture.clone();
    tex.needsUpdate = true;

    // 2. set the atlas rectangle
    const cols = 4, rows = 2;
    const fw = 1 / cols, fh = 1 / rows;
    const col = typeId % cols;
    const row = Math.floor(typeId / rows);
    tex.repeat.set(fw, fh);
    tex.offset.set(col * fw, 1 - (row + 1) * fh);

    // 3. build plane and group as before - 2x bigger base size
    const geo = new THREE.PlaneGeometry(3.0, 5.0);
    const mat = new THREE.MeshBasicMaterial({
        map: tex,
        transparent: true,
        side: THREE.FrontSide,
        depthTest: true,
        depthWrite: false
    });
    // Apply a random tint so trees vary in color subtly
    mat.color.set(randomTreeTint());
    const mesh = new THREE.Mesh(geo, mat);

    // Get the calculated offset and apply it
    const yOffset = (treeSpriteOffsets[typeId] || 0) * 5.0; // 5.0 is plane height
    mesh.position.set(0, 2.5 - yOffset, 0);   // center at 2.5, then shift down by offset

    const group = new THREE.Group();
    group.add(mesh);
    return group;
}
//keydown
        function updateTreeGrowth() {
            const now = Date.now();
            
            // Only update once per minute (60,000 milliseconds)showNotification createTreeMesh
            if (now - lastGrowthUpdate < 60000) {
                return;
            }
            
            lastGrowthUpdate = now;
            
            trees.forEach(tree => {
                if (tree.isFalling) return;
                
                // Calculate minutes since planting
                const minutesSincePlanted = Math.floor((now - tree.plantedTime) / 60000);
                
                // Grow tree in stages (up to 10 minutes)
                if (minutesSincePlanted < 10) {
                    tree.growthStage = minutesSincePlanted + 1;
                    
                    // Calculate scale based on growth stage (0.5 to 1.0)
                    const growthScale = 0.5 + (tree.growthStage / 10) * 0.5;
                    
                    // Apply growth to the group scale using stored size variation
                    tree.group.scale.set(
                        tree.sizeVariation * growthScale,
                        tree.sizeVariation * growthScale,
                        1
                    );
                }
                
                // Handle fruit respawning (after 10 minutes)
                if (tree.isFruitTree && tree.fruitPicked && tree.fruitPickTime) {
                    const minutesSincePicked = (now - tree.fruitPickTime) / 60000; // Convert to minutes
                    
                    if (minutesSincePicked >= 10) {
                        // Fully respawn fruit after 10 minutes - swap back to fruit texture for all copies
                        tree.fruitPicked = false;
                        tree.fruitPickTime = null;
                        for (const treeCopy of tree.group.children) {
                            updateTreeTexture(treeCopy.children[0], tree.type, true);
                        }
                    }
                }
            });
        }
        
        function plantTree() {
            if (!plantingSeeds) {
                showNotification("Select seeds to plant");
                return;
            }
            
            if ((inventory['Seeds'] || 0) <= 0) {
                showNotification("No seeds in inventory");
                return;
            }
            
            if (playerLastMoveDirection.lengthSq() === 0) {
                showNotification("Move first to target a spot");
                return;
            }

            // Determine target position
            const playerX = Math.round(playerPos.x);
            const playerZ = Math.round(playerPos.z);
            const dirX = Math.round(playerLastMoveDirection.x);
            const dirZ = Math.round(playerLastMoveDirection.z);
            
            const targetX = playerX + dirX;
            const targetZ = playerZ + dirZ;
            
            // Check if position is valid
            if (targetX < 0 || targetX >= worldSize || targetZ < 0 || targetZ >= worldSize) {
                showNotification("Cannot plant outside world boundaries");
                return;
            }
            
            // Check if there's already a tree at this position or too close
            const minTreeDistance = 2;
            const existingTree = trees.find(tree => {
                const distance = Math.sqrt((targetX - tree.x) ** 2 + (targetZ - tree.z) ** 2);
                return distance < minTreeDistance;
            });
            if (existingTree) {
                showNotification("Trees must be at least 2 blocks apart");
                return;
            }
            
            // Find the top terrain height at target position
            let topY = 0;
            if (terrain[targetX] && terrain[targetX][targetZ]) {
                for (let y = worldSize - 1; y >= 0; y--) {
                    if (terrain[targetX][targetZ][y] !== undefined) {
                        topY = y;
                        break;
                    }
                }
            }
            
            // Check if the top block is soil
            if (topY === 0 || (terrain[targetX] && terrain[targetX][targetZ] && 
                terrain[targetX][targetZ][topY - 1] !== MATERIALS.SOIL.id)) {
                showNotification("Can only plant trees on soil");
                return;
            }
            
            // Randomly select tree type
            const treeType = Math.floor(Math.random() * TREE_TYPES.length);
            
            // Consume seed
inventory['Seeds']--;

const treeGroup = createTreeMesh(treeType);

// Start planted trees at a smaller size (50% for visibility)
const initialScaleFactor = 0.5;
// Add random size variation (70% to 130%)
const sizeVariation = 0.7 + Math.random() * 0.6;
treeGroup.scale.set(sizeVariation * initialScaleFactor, sizeVariation * initialScaleFactor, 1);

// Create a parent group to hold 9 copies for seamless wrapping
const treeParent = new THREE.Group();
for (let offsetX = -1; offsetX <= 1; offsetX++) {
    for (let offsetZ = -1; offsetZ <= 1; offsetZ++) {
        const treeCopy = treeGroup.clone();
        treeCopy.position.set(targetX + offsetX * worldSize, topY + 0.5, targetZ + offsetZ * worldSize);
        treeParent.add(treeCopy);
    }
}
scene.add(treeParent);

            // 20% chance new planted tree is a fruit tree
            const isFruitTree = Math.random() < 0.2;
            const fruitCount = isFruitTree ? (1 + Math.floor(Math.random() * 6)) : 0;
            
            // If this is a fruit tree, swap to fruit texture for all copies
            if (isFruitTree) {
                for (const treeCopy of treeParent.children) {
                    updateTreeTexture(treeCopy.children[0], treeType, true);
                }
            }

trees.push({
    x: targetX, z: targetZ, y: topY,
    position: new THREE.Vector3(targetX + 0.5, topY + 3.0, targetZ + 0.5),
    type: treeType,
    group: treeParent,
    mesh: treeParent.children[4].children[0], // Center copy
                wood: TREE_TYPES[treeType].minWood + Math.floor(Math.random() * (TREE_TYPES[treeType].maxWood - TREE_TYPES[treeType].minWood + 1)),
    seeds: TREE_TYPES[treeType].minSeeds + Math.floor(Math.random() * (TREE_TYPES[treeType].maxSeeds - TREE_TYPES[treeType].minSeeds + 1)),
    isFalling: false,
    fallProgress: 0,
    fallDirection: 1,
    plantedTime: Date.now(),
                growthStage: 5,  // Start at growth stage 5 (50% size for better visibility)
                sizeVariation: sizeVariation, // Store the random size for growth calculations
                isFruitTree,
                fruit: fruitCount,
                fruitPicked: false,
                fruitPickTime: null,
                maxFruit: fruitCount
});

updateInventoryUI();
showNotification(`Planted a ${TREE_TYPES[treeType].name} sapling`);
             }
//updateFallin generateTree
        function placeBlockInDirection() {
            if (equippedTool) {
                showNotification("Unequip tool first!");
                return;
            }
            
            if (plantingSeeds) {
                plantTree();
                return;
            }
            
            if (plantingBushSeeds) {
                plantBush();
                return;
            }
            
            if (selectedMaterials.size !== 1) {
                showNotification("Select exactly one material to build");
                return;
            }
            
            const selectedMaterialId = selectedMaterials.values().next().value;
            const selectedMaterial = Object.values(MATERIALS).find(m => m.id === selectedMaterialId);
            
            if ((inventory[selectedMaterial.name] || 0) <= 0) {
                showNotification(`No ${selectedMaterial.name} in inventory`);
                return;
            }

            const playerX = Math.floor(playerPos.x);
            const playerFeetY = Math.floor(playerPos.y - 1.0);
            const playerZ = Math.floor(playerPos.z);

            // Determine direction - use last move direction or try all directions
            let dirX = 0;
            let dirZ = 0;
            
            if (playerLastMoveDirection && playerLastMoveDirection.lengthSq() > 0) {
                dirX = Math.round(playerLastMoveDirection.x);
                dirZ = Math.round(playerLastMoveDirection.z);
            }

            // Try to place block at various positions around the player
            let placementCandidates = [];
            
            // If we have a direction, try that first
            if (dirX !== 0 || dirZ !== 0) {
                const targetX = playerX + dirX;
                const targetZ = playerZ + dirZ;
                placementCandidates.push(
                    { x: targetX, y: playerFeetY - 1, z: targetZ },  // Below feet in direction
                    { x: targetX, y: playerFeetY, z: targetZ },      // At feet level in direction
                    { x: targetX, y: playerFeetY + 1, z: targetZ }   // At waist level in direction
                );
            }
            
            // Also try adjacent to player in all directions
            const directions = [
                { dx: 1, dz: 0 }, { dx: -1, dz: 0 },
                { dx: 0, dz: 1 }, { dx: 0, dz: -1 }
            ];
            
            for (const dir of directions) {
                const targetX = playerX + dir.dx;
                const targetZ = playerZ + dir.dz;
                placementCandidates.push(
                    { x: targetX, y: playerFeetY - 1, z: targetZ },
                    { x: targetX, y: playerFeetY, z: targetZ }
                );
            }

            // Find valid spot
            let targetSpot = null;
            for (const candidate of placementCandidates) {
                let { x, y, z } = candidate;

                const wrappedX = ((x % worldSize) + worldSize) % worldSize;
                const wrappedZ = ((z % worldSize) + worldSize) % worldSize;

                if (y < 0 || y >= worldSize) continue;

                if (blockMeshes[wrappedX]?.[z]?.[y]) {
                    continue; // Occupied
                }

                // Check support
                let hasSupport = false;
                // Support below
                if (y > 0 && terrain[wrappedX]?.[wrappedZ]?.[y - 1] !== undefined) hasSupport = true;
                // Support adjacent
                const adj = [
                    { dx: 1, dz: 0 }, { dx: -1, dz: 0 }, { dx: 0, dz: 1 }, { dx: 0, dz: -1 }
                ];
                for (const d of adj) {
                    const nx = (wrappedX + d.dx + worldSize) % worldSize;
                    const nz = (wrappedZ + d.dz + worldSize) % worldSize;
                    if (terrain[nx]?.[nz]?.[y] !== undefined) hasSupport = true;
                }
                
                if (!hasSupport && y > 0) continue; // Need support unless at bottom? well usually need support

                // Don't place inside player
                const wrappedPlayerX = ((playerX % worldSize) + worldSize) % worldSize;
                const wrappedPlayerZ = ((playerZ % worldSize) + worldSize) % worldSize;
                if (wrappedX === wrappedPlayerX && wrappedZ === wrappedPlayerZ && 
                    y >= playerFeetY && y <= playerFeetY + 1) {
                    continue;
                }
                
                targetSpot = { x: wrappedX, y, z: wrappedZ };
                break;
            }

            if (targetSpot) {
                const onComplete = () => {
                    const { x, y, z } = targetSpot;
                    // Check inventory again
                    if ((inventory[selectedMaterial.name] || 0) <= 0) return;
                    // Check vacancy again
                    if (blockMeshes[x]?.[z]?.[y]) return;

                    const newBlockMesh = createBlock(x, y, z, selectedMaterial);
                    blockMeshes[x][z][y] = newBlockMesh;
                    terrain[x][z][y] = selectedMaterial.id;

                    inventory[selectedMaterial.name]--;
                    updateInventoryUI();
                    updateSurroundingBlockVisibility(x, y, z);
                    showNotification(`Placed ${selectedMaterial.name} block`);
                    saveGameState();
                };
                
                startLongAction('construction', onComplete, null, 20000);
            } else {
                showNotification("No space for placement nearby");
            }
        }
//rLastMoveDire
        function getBlockMeshAt(x, y, z) {
            if (x < 0 || x >= worldSize || y < 0 || y >= worldSize || z < 0 || z >= worldSize) {
                return undefined;
            }
            return blockMeshes[x]?.[z]?.[y];
        }

        function checkTreesAboveBlock(x, y, z) {
            // Check if any trees are standing on or near this position
            for (let i = trees.length - 1; i >= 0; i--) {
                const tree = trees[i];
                
                // Check if tree is at this x,z position
                if (Math.round(tree.x) === x && Math.round(tree.z) === z) {
                    // Check if the tree's ground level (tree.y) is at or above the destroyed block
                    if (tree.y === y || tree.y === y + 1) {
                        // Check if there's still soil beneath the tree
                        let hasSoilBeneath = false;
                        if (terrain[x] && terrain[x][z]) {
                            for (let checkY = y - 1; checkY >= 0; checkY--) {
                                if (terrain[x][z][checkY] !== undefined) {
                                    if (terrain[x][z][checkY] === MATERIALS.SOIL.id) {
                                        hasSoilBeneath = true;
                                    }
                                    break;
                                }
                            }
                        }
                        
                        // If no soil beneath, remove the tree
                        if (!hasSoilBeneath) {
                            scene.remove(tree.group);
                            trees.splice(i, 1);
                            showNotification("Tree collapsed!");
                        }
                    }
                }
            }
        }

        function updateSurroundingBlockVisibility(changedX, changedY, changedZ) {
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        const checkX = changedX + dx;
                        const checkY = changedY + dy;
                        const checkZ = changedZ + dz;

                        if (checkX >= 0 && checkX < worldSize &&
                            checkY >= 0 && checkY < worldSize &&
                            checkZ >= 0 && checkZ < worldSize) {

                            const materialId = terrain[checkX]?.[checkZ]?.[checkY];
                            const currentMesh = blockMeshes[checkX]?.[checkZ]?.[checkY];

                            if (materialId !== undefined) {
                                const isCurrentlyVisible = (currentMesh !== undefined);
                                const shouldBeVisible = isBlockVisibleRuntime(checkX, checkY, checkZ);

                                if (shouldBeVisible && !isCurrentlyVisible) {
                                    let materialToRender;
                                    for (const key in MATERIALS) {
                                        if (MATERIALS[key].id === materialId) {
                                            materialToRender = MATERIALS[key];
                                            break;
                                        }
                                    }
                                    if (materialToRender) {
                                        const newBlockMesh = createBlock(checkX, checkY, checkZ, materialToRender);
                                        blockMeshes[checkX][checkZ][checkY] = newBlockMesh;
                                    }
                                } else if (!shouldBeVisible && isCurrentlyVisible) {
                                    scene.remove(currentMesh);
                                    // Dispose geometry from all 9 copies
                                    for (const blockCopy of currentMesh.children) {
                                        blockCopy.geometry.dispose();
                                    }
                                    // Don't dispose materials - they are cached and reused
                                    blockMeshes[checkX][checkZ][checkY] = undefined;
                                }
                            }
                        }
                    }
                }
            }
        }

function updateCameraPosition() {
    // distance and height stay the same
    const radius = cameraOffset.length();
    const height = 2.505;               // adjusted height for zoomed in camera

    // compute horizontal orbit position
    // Camera follows player position directly (wrapping is handled by player position updates)
    const x = playerPos.x + radius * Math.cos(cameraAngle);
    const z = playerPos.z + radius * Math.sin(cameraAngle);
    const y = playerPos.y + height;

    camera.position.set(x, y, z);
    camera.lookAt(playerPos.x, playerPos.y, playerPos.z);
}

function rotateCamera(dir) {
    cameraAngle += dir * rotationSpeed;
    updateCameraPosition();
}

        function startToolAnimation() {
            if (!isUsingTool || (currentAnimation && currentAnimation.completed)) {
                if (equippedTool && equippedTool.id === TOOLS.PICKAXE.id) {
                    currentAnimation = playerFacing === 'front' ? 
                        playerAnimationsWithPickaxe.miningFront : 
                        playerAnimationsWithPickaxe.miningBack;
                } else if (equippedTool && equippedTool.id === TOOLS.AXE.id) {
                    currentAnimation = playerFacing === 'front' ? 
                        playerAnimationsWithAxe.cuttingFront : 
                        playerAnimationsWithAxe.cuttingBack;
                } else if (equippedTool && equippedTool.id === TOOLS.SWORD.id) {
                    currentAnimation = playerFacing === 'front' ? 
                        playerAnimationsWithSword.attackFront : 
                        playerAnimationsWithSword.attackBack;
                }
                
                if (currentAnimation) {
                    currentAnimation.play();
                    isUsingTool = true;
                    toolAnimationComplete = false;
                }
            }
        }

        // Fishing mechanics functions
        function isNearWater() {
            const playerX = Math.floor(playerPos.x);
            const playerZ = Math.floor(playerPos.z);
            const playerFeetY = Math.floor(playerPos.y - 1.0);
            
            // Check in a 3x3 area around the player for water
            for (let dx = -1; dx <= 1; dx++) {
                for (let dz = -1; dz <= 1; dz++) {
                    const checkX = playerX + dx;
                    const checkZ = playerZ + dz;
                    
                    // Check for water at feet level or one level below
                    for (let dy = -1; dy <= 0; dy++) {
                        const checkY = playerFeetY + dy;
                        const block = getTerrainBlock(checkX, checkZ, checkY);
                        if (block === MATERIALS.WATER.id) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        function startFishing() {
            if (isFishing) {
                stopFishing();
                return;
            }
            if (isPerformingLongAction) {
                showNotification("Already performing an action.");
                return;
            }
            if (!isNearWater()) {
                showNotification("You need to be near water to fish!");
                return;
            }
            
            isFishing = true;
            fishingState = 'casting';
            
            currentAnimation = playerAnimationsWithFishingRod.castingFront;
            currentAnimation.play();
            showNotification("Casting line...");
            
            setTimeout(() => {
                if (isFishing && fishingState === 'casting') {
                    fishingState = 'waiting';
                    currentAnimation = playerAnimationsWithFishingRod.waitingFront;
                    currentAnimation.play();
                    showNotification("Waiting for a fish to bite...");
                    
                    startLongAction('fishing', finishFishing);
                }
            }, 800); // Casting animation duration
        }
        
        function stopFishing() {
            isFishing = false;
            fishingState = 'idle';
            
            // Return to idle animation
            if (equippedTool && equippedTool.id === TOOLS.FISHING_ROD.id) {
                currentAnimation = playerFacing === 'front' ?
                    playerAnimationsWithFishingRod.idleFront :
                    playerAnimationsWithFishingRod.idleBack;
                currentAnimation.play();
            }
            
            showNotification("Stopped fishing");
        }
        
        function finishFishing() {
            if (!isFishing) return;

            fishingState = 'bite';
            currentAnimation = playerAnimationsWithFishingRod.fishBiteFront;
            currentAnimation.play();
            
            showNotification("A fish bit! Catching it...");
            
            setTimeout(() => {
                if (isFishing && fishingState === 'bite') {
                    catchFish();
                }
            }, 800);
        }
        
        function catchFish() {
            if (!isFishing) return;
            
            fishingState = 'catching';
            currentAnimation = playerAnimationsWithFishingRod.catchingFront;
            currentAnimation.play();
            
            showNotification("Caught a fish!");
            
            // Add fish to inventory
            inventory['Fish'] = (inventory['Fish'] || 0) + 1;
            updateInventoryUI();
            saveGameState();
            
            // Return to idle after catching animation
            setTimeout(() => {
                if (isFishing) {
                    stopFishing();
                }
            }, 1000);
        }
        
        function loadState(gameState) {
            // 1. Clear existing scene and state
            showNotification("Loading new world...", 1000);

            // Remove all game objects from the scene
            for (let x in blockMeshes) {
                for (let z in blockMeshes[x]) {
                    for (let y in blockMeshes[x][z]) {
                        if (blockMeshes[x][z][y]) scene.remove(blockMeshes[x][z][y]);
                    }
                }
            }
            trees.forEach(t => scene.remove(t.group));
            bushes.forEach(b => scene.remove(b.group));
            bears.forEach(b => scene.remove(b.group));
            wolves.forEach(w => scene.remove(w.group));
            campfires.forEach(c => scene.remove(c.group));

            // Reset state arrays
            trees = [];
            bushes = [];
            bears = [];
            wolves = [];
            campfires = [];
            blockMeshes = [];
            terrain = [];

            // 2. Restore simple variables
            playerPos.set(gameState.playerPos.x, gameState.playerPos.y, gameState.playerPos.z);
            inventory = gameState.inventory;
            health = gameState.health;
            hunger = gameState.hunger;
            skills = gameState.skills;
            gameStartTime = gameState.gameStartTime;
            lastRainCycle = gameState.lastRainCycle;
            isRaining = gameState.isRaining;
            rainStartTime = gameState.rainStartTime;
            
            // Restore owned tools
            if (gameState.ownedTools) {
                ownedTools = new Set(gameState.ownedTools);
            } else {
                ownedTools = new Set([TOOLS.PICKAXE.id]);
            }

            // 3. Rebuild the world
            terrain = gameState.terrain;
            for(let x = 0; x < worldSize; x++) {
                blockMeshes[x] = [];
                for(let z = 0; z < worldSize; z++) {
                    blockMeshes[x][z] = [];
                }
            }

            // Re-create blocks
            for (let x = 0; x < worldSize; x++) {
                for (let z = 0; z < worldSize; z++) {
                    if (!terrain[x] || !terrain[x][z]) continue;
                    for (let y = 0; y < worldSize; y++) {
                        const matId = terrain[x][z][y];
                        if (matId !== undefined) {
                            const materialType = Object.values(MATERIALS).find(m => m.id === matId);
                            if (materialType && isBlockVisibleRuntime(x, y, z)) {
                                blockMeshes[x][z][y] = createBlock(x, y, z, materialType);
                            }
                        }
                    }
                }
            }

            // Re-create trees, bushes, animals, campfires
            gameState.trees.forEach(t => createTreeFromSave(t));
            gameState.bushes.forEach(b => createBushFromSave(b));
            if (gameState.campfires) {
                gameState.campfires.forEach(c => createCampfireFromSave(c));
            }
            // Note: Animal creation from save is simplified, would need more complex functions for full state
            // For now, we just respawn them. A full implementation would need createBearFromSave etc.
            generateBears(); 
            generateWolves();

            // 4. Final UI/State Updates
            updateInventoryUI();
            updateStatsUI();
            updateSkillsUI();
            updateCameraPosition();
            showNotification("Game Loaded!", 2000);
        }
        
        function createTreeFromSave(treeData) {
            const treeGroup = createTreeMesh(treeData.type);
            const scale = (0.5 + (treeData.growthStage / 10) * 0.5) * treeData.sizeVariation;
            treeGroup.scale.set(scale, scale, 1);

            const treeParent = new THREE.Group();
            for (let offsetX = -1; offsetX <= 1; offsetX++) {
                for (let offsetZ = -1; offsetZ <= 1; offsetZ++) {
                    const treeCopy = treeGroup.clone();
                    treeCopy.position.set(treeData.x + offsetX * worldSize, treeData.y + 0.5, treeData.z + offsetZ * worldSize);
                    treeParent.add(treeCopy);
                }
            }
            scene.add(treeParent);

            if (treeData.isFruitTree && !treeData.fruitPicked) {
                for (const treeCopy of treeParent.children) {
                    updateTreeTexture(treeCopy.children[0], treeData.type, true);
                }
            }

            trees.push({
                ...treeData,
                position: new THREE.Vector3(treeData.x + 0.5, treeData.y + 3.0, treeData.z + 0.5),
                group: treeParent,
                mesh: treeParent.children[4].children[0],
                isFalling: false, fallProgress: 0, fallDirection: 1,
            });
        }

                        function createBushFromSave(bushData) {

                            const bushGeo = new THREE.PlaneGeometry(1.0, 1.0);

                            const bushTex = bushTexture.clone();

                            bushTex.needsUpdate = true;

                            const frameH = 1 / 5;

                            bushTex.repeat.set(1, frameH);

                            bushTex.offset.set(0, 1 - (bushData.type + 1) * frameH);

                            const bushMat = new THREE.MeshBasicMaterial({ map: bushTex, transparent: true, side: THREE.FrontSide, depthTest: true, depthWrite: false });

                            

                            const bushGroup = new THREE.Group();

                            for (let offsetX = -1; offsetX <= 1; offsetX++) {

                                for (let offsetZ = -1; offsetZ <= 1; offsetZ++) {

                                    const bushMesh = new THREE.Mesh(bushGeo, bushMat.clone());

                                    bushMesh.position.set(

                                        bushData.x + offsetX * worldSize,

                                        bushData.y + 1.0,

                                        bushData.z + offsetZ * worldSize

                                    );

                                    bushGroup.add(bushMesh);

                                }

                            }

                            scene.add(bushGroup);

                

                            if (bushData.harvested) {

                                bushGroup.visible = false;

                            }

                

                            bushes.push({

                                ...bushData,

                                group: bushGroup,

                                mesh: bushGroup.children[4],

                                position: new THREE.Vector3(bushData.x, bushData.y + 1.0, bushData.z),

                            });

                        }

        function createCampfireFromSave(data) {
            const fireGeo = new THREE.PlaneGeometry(1, 1);
            const fireTex = campfireTexture.clone();
            fireTex.needsUpdate = true;
            fireTex.wrapS = THREE.RepeatWrapping;
            fireTex.wrapT = THREE.RepeatWrapping;
            fireTex.repeat.set(1/5, 1);
            
            const fireMat = new THREE.MeshBasicMaterial({
                map: fireTex,
                transparent: true,
                side: THREE.FrontSide,
                depthWrite: false
            });
            
            const fireMesh = new THREE.Mesh(fireGeo, fireMat);
            fireMesh.position.set(data.x + 0.5, data.y + 1.5, data.z + 0.5);
            
            const fireGroup = new THREE.Group();
            for (let offsetX = -1; offsetX <= 1; offsetX++) {
                for (let offsetZ = -1; offsetZ <= 1; offsetZ++) {
                    const copy = fireMesh.clone();
                    copy.material = fireMat.clone();
                    copy.position.set(data.x + 0.5 + offsetX * worldSize, data.y + 1.5, data.z + 0.5 + offsetZ * worldSize);
                    fireGroup.add(copy);
                }
            }
            scene.add(fireGroup);
            
            campfires.push({
                x: data.x, y: data.y, z: data.z,
                group: fireGroup,
                creationTime: data.creationTime,
                animator: new SpriteAnimator(fireTex, 5, 1, 0.15)
            });
        }

        function downloadSaveGame() {
            const gameState = {
                playerPos: { x: playerPos.x, y: playerPos.y, z: playerPos.z },
                inventory: inventory,
                health: health,
                hunger: hunger,
                skills: skills,
                gameStartTime: gameStartTime,
                lastRainCycle: lastRainCycle,
                isRaining: isRaining,
                rainStartTime: rainStartTime,
                ownedTools: Array.from(ownedTools),
                terrain: terrain,
                trees: trees.map(t => ({
                    x: t.x, y: t.y, z: t.z,
                    type: t.type,
                    wood: t.wood,
                    seeds: t.seeds,
                    plantedTime: t.plantedTime,
                    growthStage: t.growthStage,
                    sizeVariation: t.sizeVariation,
                    isFruitTree: t.isFruitTree,
                    fruit: t.fruit,
                    fruitPicked: t.fruitPicked,
                    fruitPickTime: t.fruitPickTime,
                    maxFruit: t.maxFruit
                })),
                bushes: bushes.map(b => ({
                    x: b.x, y: b.y, z: b.z,
                    type: b.type,
                    isMedicinalHerb: b.isMedicinalHerb,
                    harvested: b.harvested,
                    harvestTime: b.harvestTime
                })),
                campfires: campfires.map(c => ({
                    x: c.x, y: c.y, z: c.z,
                    creationTime: c.creationTime
                })),
                bears: bears.map(b => ({
                    x: b.position.x, y: b.position.y, z: b.position.z,
                    health: b.health,
                    state: b.state
                })),
                wolves: wolves.map(w => ({
                    x: w.position.x, y: w.position.y, z: w.position.z,
                    health: w.health,
                    state: w.state
                }))
            };

            const jsonString = JSON.stringify(gameState); // Using compact format for smaller file size
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
a.href = url;
            a.download = `sandbox-save-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showNotification("Game Saved!");
        }

        function setupControls() {
            document.addEventListener('keydown', (event) => {
                keys[event.code] = true;
                    if (event.code === 'KeyQ'){
                        rotateCamera(-1);
                    }
    if (event.code === 'KeyE'){
rotateCamera( 1)
    }
    //handleMovement
                if (event.code === 'ShiftLeft' || event.code === 'ShiftRight') {
                    event.preventDefault();
                    
                    if (equippedTool) {
                        startToolAnimation();
                        if (equippedTool.id === TOOLS.PICKAXE.id) {
                            destroyBlockInDirection();
                            attackAnimalInDirection();
                        } else if (equippedTool.id === TOOLS.AXE.id) {
                            cutTreeInDirection();
                            attackAnimalInDirection();
                        } else if (equippedTool.id === TOOLS.FISHING_ROD.id) {
                            startFishing();
                        } else if (equippedTool.id === TOOLS.SWORD.id) {
                            attackAnimalInDirection();
                        }
                    } else if (checkCrafting()) {
                        // Crafting menu opened
                    } else if (selectedMaterials.size > 0) {
                        placeBlockInDirection();
                    } else if (plantingSeeds || plantingBushSeeds) {
                        placeBlockInDirection();
                    } else if (!equippedTool && selectedMaterials.size === 0 && !plantingSeeds && !plantingBushSeeds) {
                        // Try to pick fruit or harvest herbs
                        pickFruitInDirection();
                        harvestHerbInDirection();
                        attackAnimalInDirection();
                    }
                } else if (event.code === 'Space') {
                    event.preventDefault();
                    if (equippedTool && equippedTool.id === TOOLS.PICKAXE.id) {
                        startToolAnimation();
                        destroyBlockInDirection();
                    } else if (equippedTool && equippedTool.id === TOOLS.FISHING_ROD.id) {
                        catchFish();
                    }
                } else if (event.code === 'AltLeft' || event.code === 'AltRight') {
                    event.preventDefault();
                    placeBlockInDirection();
                } else if (event.code === 'KeyF') {
                    consumeFruit();
                } else if (event.code === 'KeyH') {
                    useHerb();
                } else if (event.code === 'KeyZ') {
                    jump();
                } else if (event.code === 'KeyN') {
                    if (isNightTime) {
                        sleepPlayer();
                    }
                }
            });

            document.addEventListener('keyup', (event) => {
                keys[event.code] = false;
            });


            
            // Plant tree/bush button
            document.getElementById('plantButton').addEventListener('click', () => {
                // If user has both, prioritize what's already selected, otherwise select tree seeds
                if (plantingBushSeeds && (inventory['Bush Seeds'] || 0) > 0) {
                    // Already planting bushes, keep it
                } else if ((inventory['Seeds'] || 0) > 0) {
                    plantingSeeds = true;
                    plantingBushSeeds = false;
                } else if ((inventory['Bush Seeds'] || 0) > 0) {
                    plantingBushSeeds = true;
                    plantingSeeds = false;
                }
                selectedMaterial = null;
                equippedTool = null;
                updateInventoryUI();
                showNotification("Select a spot and press ALT to plant");
            });

            // Save/Load buttons
            document.getElementById('saveButton').addEventListener('click', downloadSaveGame);
            document.getElementById('loadButton').addEventListener('click', () => {
                document.getElementById('loadInput').click();
            });
            document.getElementById('loadInput').addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const gameState = JSON.parse(e.target.result);
                        loadState(gameState);
                    } catch (error) {
                        console.error("Failed to parse save file:", error);
                        showNotification("Error: Invalid save file.", 3000);
                    }
                };
                reader.readAsText(file);
            });
            
            // Sleep button
            document.getElementById('sleepButton').addEventListener('click', () => {
                sleepPlayer();
            });

            document.getElementById('leftMenuToggle').addEventListener('click', () => {
                const leftMenu = document.getElementById('leftMenu');
                leftMenu.classList.toggle('open');
                const toggleButton = document.getElementById('leftMenuToggle');
                if (leftMenu.classList.contains('open')) {
                    toggleButton.innerHTML = '&lt;';
                    toggleButton.style.left = '250px'; // menu width
                } else {
                    toggleButton.innerHTML = '&gt;';
                    toggleButton.style.left = '0px';
                }
            });

            document.getElementById('rightMenuToggle').addEventListener('click', () => {
                const rightMenu = document.getElementById('rightMenu');
                rightMenu.classList.toggle('open');
                const toggleButton = document.getElementById('rightMenuToggle');
                if (rightMenu.classList.contains('open')) {
                    toggleButton.innerHTML = '&gt;';
                    toggleButton.style.right = '250px';
                } else {
                    toggleButton.innerHTML = '&lt;';
                    toggleButton.style.right = '0px';
                }
            });
            
            // Auto-save every 30 seconds
            setInterval(() => {
                saveGameState();
            }, 30000);
            
            // Load saved game if exists
            loadGameState();
        }
        
        function saveGameState() {
            const gameState = {
                playerPos: { x: playerPos.x, y: playerPos.y, z: playerPos.z },
                inventory: inventory,
                health: health,
                hunger: hunger,
                gameStartTime: gameStartTime,
                lastRainCycle: lastRainCycle,
                isRaining: isRaining,
                rainStartTime: rainStartTime,
                ownedTools: Array.from(ownedTools),
                bears: bears.map(b => ({
                    x: b.x, z: b.z, health: b.health,
                    wanderDirection: { x: b.wanderDirection.x, z: b.wanderDirection.z },
                    state: b.state
                })),
                wolves: wolves.map(w => ({
                    x: w.x, z: w.z, health: w.health,
                    wanderDirection: { x: w.wanderDirection.x, z: w.wanderDirection.z },
                    state: w.state
                }))
            };
            localStorage.setItem('sandboxGameState', JSON.stringify(gameState));
        }
        
        function loadGameState() {
            const saved = localStorage.getItem('sandboxGameState');
            if (saved) {
                try {
                    const gameState = JSON.parse(saved);
                    
                    // Don't restore player position - let createPlayer() generate a new spawn location
                    // This prevents spawning on water when the page refreshes
                    
                    // Restore stats
                    inventory = gameState.inventory || {};
                    health = gameState.health || 100;
                    hunger = gameState.hunger || 100;
                    gameStartTime = gameState.gameStartTime || Date.now();
                    lastRainCycle = gameState.lastRainCycle || Date.now();
                    isRaining = gameState.isRaining || false;
                    rainStartTime = gameState.rainStartTime || Date.now();
                    
                    if (gameState.ownedTools) {
                        ownedTools = new Set(gameState.ownedTools);
                    }
                    
                    // Update UI
                    updateInventoryUI();
                    updateStatsUI();
                    // Don't call updatePlayerPosition() here - it will be called after createPlayer()
                    
                    console.log("Game state loaded from localStorage (player position reset for new spawn)");
                } catch (e) {
                    console.error("Failed to load game state:", e);
                }
            }
        }

        let billboardTargetPoint = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = performance.now();
            const deltaTime = (currentTime - lastAnimationTime) / 1000;
            lastAnimationTime = currentTime;

            // Calculate the point 100m behind the camera for billboarding
            camera.getWorldDirection(billboardTargetPoint);
            billboardTargetPoint.multiplyScalar(-100);
            billboardTargetPoint.add(camera.position);
            
            handleMovement();
            updatePlayerAnimation(deltaTime);
            updateFallingTrees(deltaTime);
            updateTreeGrowth(); // Update tree growth
            updateHungerAndHealth(); // Update hunger and health
            updateBears(deltaTime); // Update bear AI and attacks
            updateWolves(deltaTime); // Update wolf AI and attacks
            updateFollowAnimals(cats, deltaTime);
            updateFollowAnimals(chickens, deltaTime);
            updateFollowAnimals(cows, deltaTime);
            updateFollowAnimals(dragons, deltaTime);
            updateBushes(); // Update bush billboarding and regrowth
            updateCampfires(deltaTime); // Update campfires
            updateRain(deltaTime); // Update rain system and damage
            updateDayNightCycle(); // Update day/night cycle and lighting
            updateLongAction();
            updateObjectTransparency();
            
            // Make player sprite parallel to viewing plane
            if (playerSprite) {
                const angle = Math.atan2(
                    camera.position.x - playerSprite.position.x,
                    camera.position.z - playerSprite.position.z
                );
                playerSprite.rotation.y = angle;
            }
            
            renderer.render(scene, camera);
        }


        function updateObjectTransparency() {
            const playerDistToCamera = player.position.distanceTo(camera.position);

            const allObjects = [...trees, ...bushes];

            for (const obj of allObjects) {
                if (!obj.group || !obj.position) continue;

                const objDistToCamera = obj.position.distanceTo(camera.position);

                let targetOpacity = 1.0;
                let makeTransparent = false;

                if (objDistToCamera < playerDistToCamera - 1.0) {
                    makeTransparent = true;
                    const closeness = objDistToCamera / (playerDistToCamera - 1.0);
                    targetOpacity = Math.pow(closeness, 2);
                    targetOpacity = Math.max(0.0, Math.min(1.0, targetOpacity));
                }

                const processGroup = (group) => {
                    for (const child of group.children) {
                        if (child.isMesh) {
                            const material = child.material;
                            
                            const newOpacity = makeTransparent ? targetOpacity : 1.0;
                            
                            if (Math.abs(material.opacity - newOpacity) > 0.01) {
                                material.opacity = THREE.MathUtils.lerp(material.opacity, newOpacity, 0.1);
                            } else {
                                material.opacity = newOpacity;
                            }

                            if (material.opacity < 0.99) {
                                material.depthWrite = false;
                            } else {
                                material.depthWrite = true;
                            }
                            material.transparent = true;

                        } else if (child.isGroup) {
                            processGroup(child);
                        }
                    }
                };
                
                processGroup(obj.group);
            }
        }

        function cancelLongAction() {
            if (isPerformingLongAction) {
                isPerformingLongAction = false;
                if (longActionType === 'mining') {
                    miningProgressIndicator.visible = false;
                }
                longActionOnComplete = null;
                showNotification("Action cancelled.");
            }
        }

       function handleMovement() {
    // Prevent movement while fishing (except during casting)
    if (isFishing && fishingState !== 'casting') {
        return;
    }
    
    const moveSpeed = 0.18; // Increased from 0.15 to outrun bears (0.08)
    const forward = new THREE.Vector3();
    const right   = new THREE.Vector3();

    // camera's forward & right vectors on the XZ plane
    forward.subVectors(camera.position, playerPos).normalize();
    forward.y = 0;                 // stay on the ground
    forward.normalize();

    right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

    let velocity = new THREE.Vector3();

    // Fixed movement controls - WASD and arrow keys (corrected for camera perspective)
    if (keys['KeyW'] || keys['ArrowUp'])    velocity.sub(forward);   // W/Up = up (away from cam)
    if (keys['KeyS'] || keys['ArrowDown'])  velocity.add(forward);   // S/Down = down (toward cam)
    if (keys['KeyA'] || keys['ArrowLeft'])  velocity.add(right);     // A/Left = left (camera-left)
    if (keys['KeyD'] || keys['ArrowRight']) velocity.sub(right);     // D/Right = right (camera-right)

    if (velocity.lengthSq() > 0) {
        cancelLongAction();
        velocity.normalize().multiplyScalar(moveSpeed);
        
        // Calculate new position
        const newPos = playerPos.clone().add(velocity);
        const newX = Math.floor(newPos.x);
        const newZ = Math.floor(newPos.z);
        
        // Current position
        const currentX = Math.round(playerPos.x);
        const currentZ = Math.round(playerPos.z);
        const currentFeetY = Math.floor(playerPos.y - 1.0);
        
        // Check if we can move to the new position
        let canMove = false;
        let newFeetY = currentFeetY;
        
        // Check what's at the destination at current level (with wrapping)
        const blockAtCurrentLevel = getTerrainBlock(newX, newZ, currentFeetY) !== undefined;
        const blockAtHeadLevel = getTerrainBlock(newX, newZ, currentFeetY + 1) !== undefined;
        const blockAtStepUp = getTerrainBlock(newX, newZ, currentFeetY + 1) !== undefined;
        const blockAboveStepUp = getTerrainBlock(newX, newZ, currentFeetY + 2) !== undefined;
        
        // WATER COLLISION: Stop exactly at water's edge
        // Check if moving towards water by looking at destination only
        
        // Check the block at the destination position
        const destBlock = getTerrainBlock(newX, newZ, currentFeetY);
        const destBlockBelow = getTerrainBlock(newX, newZ, currentFeetY - 1);
        
        // STOP if the destination itself is water
        // This allows player to get right up to the edge (1 block away) but not onto water
        const isDestWater = destBlock === MATERIALS.WATER.id ||
                           destBlockBelow === MATERIALS.WATER.id ||
                           (destBlock === undefined && destBlockBelow === MATERIALS.WATER.id);
                           
        // Prevent movement only if destination is water
        if (isDestWater) {
            canMove = false;
        }
        else if (blockAtCurrentLevel && blockAtHeadLevel) {
            // 2+ block wall - cannot pass
            canMove = false;
        } else if (blockAtCurrentLevel) {
            // Single block at current level - try to climb
            if (blockAboveStepUp) {
                // 2+ blocks stacked - cannot climb
                canMove = false;
            } else {
                // Single block step - can climb
                canMove = true;
                newFeetY = currentFeetY + 1; // Step up
            }
        } else {
            // No block at current level - can move
            canMove = true;
            // Check if we need to step down or fall
            // (gravity will handle the falling in updatePlayerPosition)
        }
        
        // Execute movement if allowed
        if (canMove) {
            playerPos.x = newPos.x;
            playerPos.z = newPos.z;
            
            // If stepping up, adjust Y position immediately
            if (newFeetY > currentFeetY) {
                playerPos.y = newFeetY + 1 + 1.0; // block top + player height
            }
            
            playerLastMoveDirection.copy(velocity);
        }
    }

    // Wrap around world boundaries (infinite looping world)
    if (playerPos.x < 0) playerPos.x += worldSize;
    if (playerPos.x >= worldSize) playerPos.x -= worldSize;
    if (playerPos.z < 0) playerPos.z += worldSize;
    if (playerPos.z >= worldSize) playerPos.z -= worldSize;

    updatePlayerPosition();
    updateCameraPosition();
}

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            // Maintain 1/16 resolution for pixelated look
            renderer.setSize(window.innerWidth / 4, window.innerHeight / 4);
            renderer.domElement.style.width = '100vw';
            renderer.domElement.style.height = '100vh';
        });

        init();
    </script>
</body>
</html>